kola('kola.html.util.Event',[
	'kola.lang.Class'
],function(KolaClass) {
	/********************************************** 类定义 **********************************************/
	var IEStyle = (navigator.userAgent.indexOf('MSIE') != -1 && parseInt(navigator.userAgent.substr(navigator.userAgent.indexOf( 'MSIE' ) + 5, 3)) < 9);
	//FIXME:给window绑定onscroll事件没有位置信息
	var copyParams=["keyCode","componentKey","shiftKey","clientX","clientY","screenX","screenY", "offsetX", "offsetY", "wheelDeltaY","wheelDeltaX","wheelDelta"];
	/*
	 * kola事件对象
	 * @prop currentTarget 绑定时没有设置option.delegate时，currentTarget为绑定该事件的元素，设置option.delegate时，currentTarget为被代理的元素
	 * @prop data: 绑定事件时传入的数据
	 * @prop event: 浏览器内置事件对象
	 * @prop button: w3c兼容
	 * @method preventDefault: w3c兼容
	 * @method stopPropagation: w3c兼容
	 * @method stop: preventDefault & stopPropagation
	 */
	if(IEStyle){
		var DomEvent = KolaClass({
			_init :function(e){
				this.event=e;
				this.target=e.srcElement;
				this.relatedTarget = (e.fromElement == e.srcElement ? e.toElement : e.fromElement);
				if(e.button==1)
					this.button=0;
				if(e.button==4)
					this.button=1;
				if(e.button==2)
					this.button=2;
				this.pageY=e.clientY+document.documentElement.scrollTop;
				this.pageX=e.clientX+document.documentElement.scrollLeft;
				for(var i=0,il=copyParams.length;i<il;i++){
					this[copyParams[i]]=e[copyParams[i]];
				}
			},
			preventDefault:function(){this.event.returnValue=false;},
			stopPropagation:function(){this.event.cancelBubble=true;}
		});
	}else{
		var DomEvent = KolaClass({
			_init :function(e){
				this.event=e;
				this.target=e.target;
				this.button=e.button;
				this.relatedTarget = e.relatedTarget;
				this.pageX=e.pageX;
				this.pageY=e.pageY;
				for(var i=0,il=copyParams.length;i<il;i++){
					this[copyParams[i]]=e[copyParams[i]];
				}
			},
			preventDefault:function(){
				this.event.preventDefault()
			},
			stopPropagation:function(){
				this.event.stopPropagation()
			}
		});
	}
	DomEvent.prototype.stop = function(){
		this.preventDefault();
		this.stopPropagation();
	}
	
	var eventAgent = function(callback, option, e) {
		if (IEStyle) {
			e = new DomEvent(window.event);
		}else{
			e = new DomEvent(e);
		}
		//当前事件是监听外部,则从target开始，向上查找，直到到达document或者到达该元素
		if(option.out){
			var elem = e.target;
			var match = false;
			while(elem.nodeType == 1 && elem != this){
				elem = elem.parentNode;
			}
			e.currentTarget = this;
			if(elem != this)
				callback.call(option.scope || this, e);
			return;
		}
		//当前事件是代理,则从target开始，向上查找符合delegate的dom，直到找到或者到达该元素
		if(option.delegate){
			var elem = e.target;
			var match = false;
			while(elem.nodeType == 1 && elem != this){
				if(Selector.matchesSelector(elem,option.delegate)){
					match = elem;
					break;
				}
				elem = elem.parentNode;
			}
			//若target不是delegate的一部分，则放弃事件
			if(!match)
				return;
			e.currentTarget = elem;
		}else{
			e.currentTarget = this;
		}
		if(!KolaClass.isUndefined(option.data))
			e.data = option.data;
		
		callback.call(option.scope||this, e);
	};
	//light bind
	function eventBind(target,scope,callback,option) {
		return function(e) {
			return target.call(scope,callback,option,e);
		};
	}
	//删除指定的事件
	var remove = function(element, name, callback, observer) {
		//	删除listener
		if (!IEStyle) {
			if(observer.option.out)
				document.removeEventListener(name, callback, false);
			else
				element.removeEventListener(name, callback, false);
		} else {
			//	如果是监听checkbox input的onchange事件，那就需要监听替代的事件。这样做主要是解决，ie9之前，点击checkbox input时，并不会马上出发onchange事件，而是在失焦后出发onchange事件的问题
			if (name == 'change' && element.tagName && element.tagName.toLowerCase() == 'input' && element.type == 'checkbox') {
				CheckboxChange.off(element, observer);
			} else {
				if(observer.option.out)
					document.detachEvent("on"+name, callback);
				else
					element.detachEvent("on"+name, callback);
			}
		}
	};

	//常见的inline事件
	var inlineEvents = [
		'onclick', 'ondblclick', 'onmouseover', 'onmouseout', 'onmouseup', 'onmousedown',
		'onblur', 'onfocus', 'onchange', 'onsubmit'
	];

	var special={
		'unload':{},
		'mouseenter':{},
		'mouseout':{}
	}

	var exports = {
		/**
		 * 监听一个事件
		 * @param element {kolaElement} 要绑定事件的元素
		 * @param name {String} 事件名称
		 * @param callback {function} 事件的处理函数
		 * @param [option] {object} 配置参数
		 *	@option [option.scope] {Object} 指定处理函数的this，如果没有，则默认为element
		 *	@option [option.data] {ANY} 绑定事件时附带的参数，事件处理时会附加在event.data中
		 *	@option [option.delegate] {Stirng} 代理事件，如果设置，只有符合该选择器的子元素才会触发事件，并且currentTarget指向被代理的元素
		 *	@option [option.out] {Boolean} 指定事件在当前元素之外触发
		 */
		on: function(element, name, callback, option) {
			option = option || {};
			
			//	如果是IE7下触发unload事件，那就直接设置方法
			if (name == 'unload' && element == window && IEStyle) {
				element.onunload = callback;
				return this;
			}

			var observer;

			//	建立替代方法，主要是设定作用域
			observer = {
				definer: option._definer_ || callback,
				handler: eventBind(eventAgent, element, callback, option),
				option: option
			};
			
			//	缓存事件处理方法
			((element.__events || (element.__events = {}))[name] || (element.__events[name] = [])).push(observer);
					
			//	绑定事件
			if (!IEStyle) {
				if(option.out){
					document.addEventListener(name, observer.handler, false);
				}else{
					element.addEventListener(name, observer.handler, false);
				}
			} else {
				//	如果是监听checkbox input的onchange事件，那就需要监听替代的事件。这样做主要是解决，ie9之前，点击checkbox input时，并不会马上出发onchange事件，而是在失焦后出发onchange事件的问题
				if(name == 'change' && element.tagName && element.tagName.toLowerCase() == 'input' && element.type == 'checkbox') {
					CheckboxChange.on(element, observer.handler, observer);
				}else{
					if(option.out)
						document.attachEvent('on' + name, observer.handler);
					else
						element.attachEvent('on' + name, observer.handler);
				}
			}
					
			return this;
		},
		
		/*
		 * 取消元素的所有事件绑定
		 * @param {kolaElement} element 要解除事件绑定的元素
		 */
		/*
		 * 取消元素的某个类型事件绑定
		 * @param {kolaElement} element 要解除事件绑定的元素
		 * @param {String} name 要解除事件绑定的类型
		 */
		/*
		 * 取消元素的指定事件处理
		 * @param {kolaElement} element 要解除事件绑定的元素
		 * @param {String} name 要解除事件绑定的类型
		 * @param {Function} callback 要解除事件绑定的处理函数
		 */
		off: function(element, name, callback, option) {
			if (!element) return this;

			//	如果不存在事件缓存，那就不做处理
			var events = element.__events;
			if(!events) return this;
			
			//	如果不存在要移除的事件，那就是移除所有事件
			var eventType;
			if (typeof name == 'undefined') {
				//	移除所有事件
				for (var key in events) {
					if(option.out){
						this.off(document, name, callback);
						return this;
					}
					eventType = events[key];
					if (typeof eventType != 'object' || (eventType == null) || !eventType.length) continue;
					
					//	循环取消所有事件监听
					for (var i = eventType.length - 1; i >= 0; i--) {
						var observer = eventType[i];
						remove(element, key, observer.handler, observer);
					}
				}
				
				//	删除常见的inline事件
				for (var j = inlineEvents.length - 1; j >= 0; j--) {
					element[inlineEvents[i]] = null;
				}
				
				delete element.__events;
			} else {
				//	移除指定事件的监听
				
				//	如果不存在该类型的事件存储器，那就不做处理
				eventType = events[name];
				if(!eventType) return this;

				if(callback) {//	这是要取消指定的监听方法
					//	循环所有存储的事件处理方法，如果相同，那就删除之
					for(var i = eventType.length - 1; i >= 0; i--) {
						var observer = eventType[i];
						if (observer.definer == callback) {
							remove(element, name, observer.handler, observer);
							eventType.splice(i, 1);
							break;
						}
					}
		
				} else {
					//	删除所有监听事件
					for(var i = 0, il = eventType.length; i < il; i++) {
						remove(element, name, eventType[i].handler, eventType[i]);
					}
					//	删除缓存
					delete events[name];
				}		
				return this;
			}
		},
		/*
		 * 派发事件
		 * @param element
		 * @param name
		 * @param event
		 */
		fire: function(element, name, event) {
			if(IEStyle) {  
				element.fireEvent("on"+name);  
			}else{  
				var evt = document.createEvent('HTMLEvents');  
				evt.initEvent(name,true,true);  
				element.dispatchEvent(evt);  
			}
		}
	};

	if(IEStyle) {
		/* ---------------------------------- checkbox input change事件的特殊处理程序 ----------------------------------------*/

		var CheckboxChange = {
			/*
			 * 监听方法
			 */
			on: function(element, callback, obj) {
				//	设定两个方法
				var clickfn = KolaFunction.bind(CheckboxChange.fire, this, element, callback);
				var keypressfn = KolaFunction.bind(CheckboxChange.keypress, this, element, callback);

				//  记录监听方法
				obj.click = clickfn;
				obj.keypress = keypressfn;

				//  监听替代变量
				Event.on(element, 'click', clickfn);
				Event.on(element, 'keypress', keypressfn);
			},

			/*
			 * 取消对元素的替代事件的监听
			 */
			off: function(element, obj) {
				Event.off(element, 'click', obj.click);
				Event.off(element, 'keypress', obj.keypressfn);
			},

			/*
			 * keypress事件的处理方法
			 */
			keypress: function(element, callback, e){
				//	如果当前按的是空格，那就触发onchange事件
				if (e.keyCode == 32) {
					CheckboxChange.fire(element, callback);
				}
			},

			/*
			 * 触发change事件
			 */
			fire: function(element, callback){
				//	循环每个监听change的处理器，调用之执行
				KolaArray.forEach(element.__events['change'], function(obj) {
					var e = {
						srcElement: element,
						type: 'change'
					};
					obj.h(e);
				});
			}
		};
	}
	return exports;
});