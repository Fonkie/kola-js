<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<script src="../../src/kola/Packager.js" type="text/javascript"></script>
	<script src="../testsuit/testSuit.js" type="text/javascript"></script>
	<script>
		test('简单包的注册和使用', function(test) {
			
			// 定义无任何依赖的包
			kola('defineuse.simple.A', null, function() {
				
				test(arguments.length === 0, '没有依赖包时，包的生成方法却有' + arguments.length + '个注入参数');
				
				return {
					name: 'defineuse.simple.A'
				};
			});
			
			kola('defineuse.simple.A', function(A) {
				
				test(A.name == 'defineuse.simple.A'
					, '不能定义一个无任何依赖的包'
				);
				
			});
			
			kola('defineuse.simple.B', null, function() {
				
				return {
					name: 'defineuse.simple.B'
				};
			});
			
			// 定义有一个字符串形式依赖的、简单包
			kola('defineuse.simple.C', 'defineuse.simple.A', function(A) {
				
				test(arguments.length === 1, '只有一个依赖包时（字符串形式），包的生成方法却有' + arguments.length + '个注入参数');
				
				return {
					name: 'defineuse.simple.C',
					dependence: A
				};
			});
			
			kola('defineuse.simple.C', function(C) {
				
				test(C.name == 'defineuse.simple.C'
						&& C.dependence.name == 'defineuse.simple.A'
					, '如果一个包的依赖包只有一个，并且为字符串形式的话，定义不成功'
				);
				
			});
			
			// 定义只有一个依赖，并且为数组形式时的包
			kola('defineuse.simple.D', ['defineuse.simple.B'], function(B) {
				
				test(arguments.length === 1, '只有一个依赖包时（数组形式），包的生成方法却有' + arguments.length + '个注入参数');
				
				return {
					name: 'defineuse.simple.D',
					dependence: B
				};
			});
			
			kola('defineuse.simple.D', function(D) {
				
				test(D.name == 'defineuse.simple.D'
						&& D.dependence.name == 'defineuse.simple.B'
					, '如果一个包的依赖包只有一个，并且放到数组中的话，定义不成功'
				);
				
			});
			
			// 定义有两个依赖
			kola('defineuse.simple.E', [
				'defineuse.simple.A', 'defineuse.simple.B'
			], function(A, B) {
				
				test(arguments.length === 2, '有多个依赖包时，包生成方法的注入参数个数却与依赖包的个数不同');
				
				return {
					name: 'defineuse.simple.E',
					dependence: [A, B]
				};
			});
			
			kola('defineuse.simple.E', function(E) {
				
				test(E.name == 'defineuse.simple.E'
						&& E.dependence.length == 2
						&& E.dependence[0].name == 'defineuse.simple.A'
						&& E.dependence[1].name == 'defineuse.simple.B'
					, '如果有多个依赖包，定义不成功'
				);
				
			});
			
			// 定义多个依赖
			kola('defineuse.simple.F', [
				'defineuse.simple.A'
				, 'defineuse.simple.B'
				, 'defineuse.simple.C'
				, 'defineuse.simple.D'
				, 'defineuse.simple.E'
			], function(A, B, C, D, E) {
				
				test(arguments.length === 5, '有多个依赖包时，包生成方法的注入参数个数却与依赖包的个数不同');
				
				return {
					name: 'defineuse.simple.F',
					dependence: [A, B, C, D, E]
				};
			});
			
			kola('defineuse.simple.F', function(F) {
				
				test(F.name == 'defineuse.simple.F'
						&& F.dependence.length == 5
						&& F.dependence[0].name == 'defineuse.simple.A'
						&& F.dependence[1].name == 'defineuse.simple.B'
						&& F.dependence[2].name == 'defineuse.simple.C'
						&& F.dependence[3].name == 'defineuse.simple.D'
						&& F.dependence[4].name == 'defineuse.simple.E'
					, '如果有多个依赖包，定义不成功'
				);
				
			});
			
			// 测试use一个包，并且是string类型
			kola('defineuse.simple.A', function(A) {
				
				test(arguments.length === 1
					, '使用一个包（字符串形式）执行方法时，注入参数的个数却是' + arguments.length
				);
				
				test(A.name == 'defineuse.simple.A'
					, '使用一个包（字符串形式）执行方法时，注入的参数不是依赖的那个包'
				);
				
			});
			
			// 测试use一个包，并且是Array类型
			kola(['defineuse.simple.B'], function(B) {
				
				test(arguments.length === 1
					, '使用一个包（Array形式）执行方法时，注入参数的个数却是' + arguments.length
				);
				
				test(B.name == 'defineuse.simple.B'
					, '使用一个包（Array形式）执行方法时，注入的参数不是依赖的那个包'
				);
				
			});
			
			// 测试use多个包
			kola([
					'defineuse.simple.A'
					, 'defineuse.simple.B'
					, 'defineuse.simple.C'
					, 'defineuse.simple.D'
					, 'defineuse.simple.E'
					, 'defineuse.simple.F'
				], function(A, B, C, D, E, F) {
				
					test(arguments.length === 6
						, '使用多个包执行方法时，注入参数的个数与使用包的个数不符'
					);
					
					test(A.name == 'defineuse.simple.A'
							&& B.name == 'defineuse.simple.B'
							&& C.name == 'defineuse.simple.C'
							&& C.dependence.name == 'defineuse.simple.A'
							&& D.name == 'defineuse.simple.D'
							&& D.dependence.name == 'defineuse.simple.B'
							&& E.name == 'defineuse.simple.E'
							&& E.dependence.length == 2
							&& E.dependence[0].name == 'defineuse.simple.A'
							&& E.dependence[1].name == 'defineuse.simple.B'
							&& F.name == 'defineuse.simple.F'
							&& F.dependence.length == 5
							&& F.dependence[0].name == 'defineuse.simple.A'
							&& F.dependence[1].name == 'defineuse.simple.B'
							&& F.dependence[2].name == 'defineuse.simple.C'
							&& F.dependence[3].name == 'defineuse.simple.D'
							&& F.dependence[4].name == 'defineuse.simple.E'
						, '使用多个包执行方法时，注入的参数不是依赖的那个包'
					);
				
			});
			
			// 测试use一个包，并且是string类型，并设置scope
			kola('defineuse.simple.A', function(A) {
				
				test(arguments.length === 1
					, '使用一个包（字符串形式）执行方法时，并设置了方法的scope，注入参数的个数却是' + arguments.length
				);
				
				test(A.name == 'defineuse.simple.A'
					, '使用一个包（字符串形式）执行方法时，并设置了方法的scope，注入的参数不是依赖的那个包'
				);
				
				test(this.name == 'scope of A', '使用一个包（字符串形式）执行方法时，并设置了其scope，但是方法执行时，其scope却不是设定的那个scope');
				
			}, {
				name: 'scope of A'
			});
			
			// 测试use一个包，并且是Array类型，并设置scope
			kola(['defineuse.simple.B'], function(B) {
				
				test(arguments.length === 1
					, '使用一个包（Array形式）执行方法时，并设置了方法的scope，注入参数的个数却是' + arguments.length
				);
				
				test(B.name == 'defineuse.simple.B'
					, '使用一个包（Array形式）执行方法时，并设置了方法的scope，注入的参数不是依赖的那个包'
				);
				
				test(this.name == 'scope of B', '使用一个包（Array形式）执行方法时，并设置了其scope，但是方法执行时，其scope却不是设定的那个scope');
				
			}, {
				name: 'scope of B'
			});
			
			// 测试use多个包，并设置scope
			kola([
					'defineuse.simple.A'
					, 'defineuse.simple.B'
					, 'defineuse.simple.C'
					, 'defineuse.simple.D'
					, 'defineuse.simple.E'
					, 'defineuse.simple.F'
				], function(A, B, C, D, E, F) {
				
					test(arguments.length === 6
						, '使用多个包执行方法时，并设置了方法的scope，注入参数的个数与使用包的个数不符'
					);
					
					test(A.name == 'defineuse.simple.A'
							&& B.name == 'defineuse.simple.B'
							&& C.name == 'defineuse.simple.C'
							&& C.dependence.name == 'defineuse.simple.A'
							&& D.name == 'defineuse.simple.D'
							&& D.dependence.name == 'defineuse.simple.B'
							&& E.name == 'defineuse.simple.E'
							&& E.dependence.length == 2
							&& E.dependence[0].name == 'defineuse.simple.A'
							&& E.dependence[1].name == 'defineuse.simple.B'
							&& F.name == 'defineuse.simple.F'
							&& F.dependence.length == 5
							&& F.dependence[0].name == 'defineuse.simple.A'
							&& F.dependence[1].name == 'defineuse.simple.B'
							&& F.dependence[2].name == 'defineuse.simple.C'
							&& F.dependence[3].name == 'defineuse.simple.D'
							&& F.dependence[4].name == 'defineuse.simple.E'
						, '使用多个包执行方法时，并设置了方法的scope，注入的参数不是依赖的那个包'
					);
				
					test(this.name == 'scope of ABCDEF', '使用多个包执行方法时，并设置了其scope，但是方法执行时，其scope却不是设定的那个scope');
				
			}, {
				name: 'scope of ABCDEF'
			});
			
		});
		
		test('测试文件加载', function(test) {
			
			kola({
				
				libs: {
					'simple': {
						path: '/test/kola/Packager.support/simple/'
					}
				}
				
			});
			
			// 测试use一个包，并且是string类型
			kola('simple.A', function(A) {
				
				test(A.name == 'simple.A'
					, '使用一个包（字符串形式）执行方法时，注入的参数不是依赖的那个包'
				);
				
			});
			
			// 测试use一个包，并且是Array类型
			kola(['simple.hasdependence.C'], function(C) {
				
				test(C.name == 'simple.hasdependence.C'
					, '使用一个包（Array形式）执行方法时，注入的参数不是依赖的那个包'
				);
				
			});
			
			// 测试use多个包
			kola([
					'simple.A'
					, 'simple.B'
					, 'simple.hasdependence.C'
					, 'simple.hasdependence.D'
					, 'simple.hasdependence.manydependence.E'
					, 'simple.hasdependence.manydependence.F'
				], function(A, B, C, D, E, F) {
				
					test(arguments.length === 6
						, '使用多个包执行方法时，注入参数的个数与使用包的个数不符'
					);
					
					test(A.name == 'simple.A'
							&& B.name == 'simple.B'
							&& C.name == 'simple.hasdependence.C'
							&& C.dependence.name == 'simple.A'
							&& D.name == 'simple.hasdependence.D'
							&& D.dependence.name == 'simple.B'
							&& E.name == 'simple.hasdependence.manydependence.E'
							&& E.dependence.length == 2
							&& E.dependence[0].name == 'simple.A'
							&& E.dependence[1].name == 'simple.B'
							&& F.name == 'simple.hasdependence.manydependence.F'
							&& F.dependence.length == 5
							&& F.dependence[0].name == 'simple.A'
							&& F.dependence[1].name == 'simple.B'
							&& F.dependence[2].name == 'simple.hasdependence.C'
							&& F.dependence[3].name == 'simple.hasdependence.D'
							&& F.dependence[4].name == 'simple.hasdependence.manydependence.E'
						, '使用多个包执行方法时，注入的参数不是依赖的那个包'
					);
					
					test(this.name == 'scope of ABCDEF loading with packages config'
						, '使用包执行方法时，假如包时通过外部文件动态加载，这是给方法设置的scope并没有应用到方法上');
				
			}, {
				name: 'scope of ABCDEF loading with packages config'
			});
			
		});
		
		/*
		test('测试注册或使用包时，自动错误提示的功能', function() {
			
			// TODO: 测试错误的地址
			
			// TODO: 测试错误的包内容
			
		});
		
		test('注册包，非正常使用测试', function(test) {
			
			// TODO: 测试重复注册
			
		});
		*/
	</script>
</head>
<body>
	
</body>
</html>