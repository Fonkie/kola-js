<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>kola\Package.js - kola</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="kola"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Array.html">Array</a></li>
            
                <li><a href="..&#x2F;classes/Class.html">Class</a></li>
            
                <li><a href="..&#x2F;classes/Function.html">Function</a></li>
            
                <li><a href="..&#x2F;classes/Package.html">Package</a></li>
            
                <li><a href="..&#x2F;classes/String.html">String</a></li>
            
                <li><a href="..&#x2F;classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/kola.html">kola</a></li>
            
                <li><a href="..&#x2F;modules/kola.lang.html">kola.lang</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: kola\Package.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * kola系统的核心，负责包的加载、管理和使用
 * 
 * @module kola
 * @main
 * 
 * @author Jady Yang
 *&#x2F;

(function() {
	&#x2F;&#x2F;	TODO: 循环依赖的问题，需要解决

	&#x2F;********************************************** functions **********************************************&#x2F;
	
	&#x2F;**
	 * 删除字符串中的所有空格
	 * @param {string} string 要删除空格的字符串
	 * @type string
	 * @return 去除空格后的新字符串
	 *&#x2F;
	function trim(string) {
		var reg = &#x2F;\s&#x2F;g;
		trim = function(string) {
			return string.replace(reg, &#x27;&#x27;);
		};
		return trim(string);
	}
	
	&#x2F;**
	 * 循环数组中的每一项，依次交给迭代器执行
	 * @param {Array} array 要循环的数组
	 * @param {function} iterator 迭代器
	 *&#x2F;
	function each(array, iterator) {
		for (var i=0, l=array.length; i&lt;l; i++) {
			iterator(array[i]);
		}
	}

	&#x2F;**
	 * 绑定执行域和方法参数
	 * @param {function} func 要绑定的方法
	 * @param {Object} scope 执行域
	 * @type Function
	 * @return Function
	 *&#x2F;
	function bind(func, scope) {
		var args = [];
		for (var i=2, il=arguments.length; i&lt;il; i++) {
			args.push(arguments[i]);
		}
		return function() {
			var thisArgs = args.concat();
			for (var i=0, il=arguments.length; i&lt;il; i++) {
				thisArgs.push(arguments[i]);
			}
			return func.apply(scope, thisArgs);
		};
	}

	&#x2F;**
	 * 把字符串去除所有空格，并用逗号分隔成为一个数组
	 *&#x2F;
	function toArray(string) {
		switch (typeof(string)) {
			case &#x27;string&#x27;:
				string = (string = trim(string)).split(&#x27;,&#x27;);
			case &#x27;object&#x27;:
			    if (string instanceof Array) {
				    if (string.length == 0) return null;
				    return string;
			    }
			default:
				return null;
		}
	}

	&#x2F;**
	 * 拷贝对象
	 *&#x2F;
	function clone(object) {
		switch (typeof(object)) {
			case &#x27;object&#x27;:
				if (object != null &amp;&amp; typeof(object.length) == &#x27;number&#x27;) {
					return object.concat();
				}
				break;
		}
		return object;
	}

	function createClass( SuperClass, Methods ) {
		&#x2F;&#x2F;	判断是否存在要继承的父类
		if ( typeof(Methods) == &#x27;undefined&#x27; ) {
			Methods = SuperClass;
			SuperClass = null;
		}

		var SubClass;

		&#x2F;&#x2F;	判断是否存在方法直接量
		var me = Methods.__ME;
		if ( me ) {
			&#x2F;&#x2F;	存在方法直接量

			&#x2F;&#x2F;	提供能够识别两种调用模式的方法构造体
			SubClass = function() {

				&#x2F;&#x2F;	如果标识符不是数字，那说明类继承体系出现了问题
				var i = this.__I;
				if ( typeof( i ) != &#x27;number&#x27; || i !== 0) {
					&#x2F;&#x2F;	直接调用方式
					return me.apply( SubClass, arguments );
				} else {
					this.constructor = SubClass;
					this.__I = 1;
					&#x2F;&#x2F;	这是类方式
					this._init.apply( this, arguments );
					this.__I = 4;
				}
			};
		} else {
			&#x2F;&#x2F;	创建新类的方法
			SubClass = function() {
				this.constructor = SubClass;
				this._init.apply(this, arguments);
			};
		}

		var agencyInstance;
		if ( SuperClass == null ) {
			&#x2F;&#x2F;	不存在父类的话
			agencyInstance = Methods;
		} else {
			&#x2F;&#x2F;	存在父类的话，那就创建一个中间的缓冲类

			var AgencyClass = function() {};
			AgencyClass.prototype = SuperClass.prototype;
			agencyInstance = new AgencyClass();
			
			&#x2F;&#x2F;	循环添加每个插件对象到原型上
			var aops = [];
			for ( var i = 1, il = arguments.length; i &lt; il; i++ ) {
				var proto = arguments[i];
				for ( var item in proto ) {
					var before = -1,
						after = -1,
						index = -1,
						realName = &#x27;&#x27;;
						
					&#x2F;&#x2F;	如果存在前置切面方法，那就处理之
					if ((before = item.indexOf(&#x27;__before__&#x27;)) != -1) {
						realName = item.substring(0, before);
						if (typeof (index = aops[realName]) != &#x27;number&#x27;) {
							index = aops[realName] = aops.length;
							aops.push({
								name: realName,
								befores: [],
								afters: []
							});
						}
						aops[index].befores.push(proto[item]);
					}
						
					&#x2F;&#x2F;	如果存在前置切面方法，那就处理之
					if ((after = item.indexOf(&#x27;__after__&#x27;)) != -1) {
						realName = item.substring(0, after);
						if (typeof (index = aops[realName]) != &#x27;number&#x27;) {
							index = aops[realName] = aops.length;
							aops.push({
								name: realName,
								befores: [],
								afters: []
							});
						}
						aops[index].afters.push(proto[item]);
					}
					
					&#x2F;&#x2F;	只有当当前方法不是切面方法时，才予以添加
					if (before == -1 &amp;&amp; after == -1) {
						agencyInstance[item] = proto[item];
					}
				}
			}
			
			&#x2F;&#x2F;	如果存在切面方法，那就替代相应方法
			if (aops.length &gt; 0) {
				var Prototype = SuperClass.prototype;
				for (var i = 0, il = aops.length; i &lt; il; i++) {
					var aop = aops[i];
					
					&#x2F;&#x2F;	生成替代方法
					agencyInstance[aop.name] = createAopedFunc(Prototype[aop.name], aop);
				}
			}

			&#x2F;&#x2F;	设置实例的_super属性
			agencyInstance._super = AgencyClass.prototype;
		}

		&#x2F;&#x2F;	设置类实例标识符
		agencyInstance.__I = 0;

		SubClass.prototype = agencyInstance;		&#x2F;&#x2F;	设置新类的原型

		return SubClass;
	}
	
	&#x2F;**
	 * 生成一个新的Aop方法
	 * @param {Function} func 原生的方法
	 * @param {Object} aop aop配置参数
	 *&#x2F;
	function createAopedFunc(func, aop) {
		return function() {
			var args = [];
			for (var i = 0, il = arguments.length; i &lt; il; i++) {
				args.push(arguments[i]);
			}
			
			&#x2F;&#x2F;	如果存在调用前的方法，那就调用之
			var befores = aop.befores;
			if (befores.length &gt; 0) {
				for (var i = 0, il = befores.length; i &lt; il; i++) {
					var tempResult = befores[i].apply(this, args);
					if (typeof tempResult != &#x27;undefined&#x27;) {
						args = tempResult;
					}
				}
			}
			
			&#x2F;&#x2F;	调用原来的方法
			var result = func.apply(this, args);
			
			&#x2F;&#x2F;	如果存在调用后的方法，那就调用之
			var afters = aop.afters;
			if (afters.length &gt; 0) {
				args.unshift(result);
				for (var i = 0, il = afters.length; i &lt; il; i++) {
					var tempResult = afters[i].apply(this, args);
					if (typeof tempResult != &#x27;undefined&#x27;) {
						args = tempResult;
					}
				}
				result = args[0];
			}
			
			return result;
		};
	}

	&#x2F;********************************************** About DOMContentLoaded **********************************************&#x2F;

	var domLoaded,			&#x2F;&#x2F;	is Dom Loaded
		domFollowers;		&#x2F;&#x2F;	跟踪domload事件的方法列表

	&#x2F;**
	 * domload事件之后的回调方法
	 *&#x2F;
	function loadedDom() {
		domLoaded = true;
		&#x2F;&#x2F;	循环每个事件的跟踪者，执行相应的方法
		if (!domFollowers) return;
		for (var i = 0, il = domFollowers.length; i &lt; il; i++) {
			var func = domFollowers[i];
			switch (typeof(func)) {
				case &#x27;function&#x27;:
					func();
					break;
				case &#x27;object&#x27;:
					if (func.length == 3) {
						func[0].apply(func[1], func[2]);
					}
					break;
			}
		}
		domFollowers = null;
	}
	
	&#x2F;**
	 * 针对ie 判断是否domContent ready
	 *&#x2F;
	function doScrollCheck() {
		if ( domLoaded==true ) {
			return;
		}
	
		try {
			&#x2F;&#x2F; If IE is used, use the trick by Diego Perini
			&#x2F;&#x2F; http:&#x2F;&#x2F;javascript.nwbox.com&#x2F;IEContentLoaded&#x2F;
			document.documentElement.doScroll(&quot;left&quot;);
		} catch(e) {
			setTimeout( doScrollCheck, 1 );
			return;
		}
		loadedDom();
	}

	&#x2F;**
	 * 指定某个方法跟踪dom load事件，并得到新的方法，以后别的程序使用
	 * @param {Function} callbackfn 跟踪domload的方法
	 * @return 得到的新方法
	 * @type Function
	 *&#x2F;
	function waitLoaded(callbackfn, feedback) {
		&#x2F;&#x2F;	如果能够获取dom的状态，那就直接以此为标准
		var state = document.readyState;

		if ( typeof( state ) == &#x27;string&#x27; &amp;&amp; ( state == &#x27;complete&#x27; || state == &#x27;interactive&#x27; ) ) {
			domLoaded = true;
		} else {
			&#x2F;&#x2F;	启动对domloaded事件的跟踪，针对不同的浏览器进行不同的处理
			domLoaded = false;
			domFollowers = [];

			if (document.addEventListener) {
				&#x2F;&#x2F;	Mozilla、Opera和webkit已经支持了该事件
				document.addEventListener(&quot;DOMContentLoaded&quot;, function(){
					document.removeEventListener( &quot;DOMContentLoaded&quot;, arguments.callee, false );  
					loadedDom();
				}, false);
				
				window.addEventListener( &quot;load&quot;, loadedDom, false );
			} else if (document.attachEvent) {
		
				&#x2F;&#x2F;	针对IE的处理
				document.attachEvent(&quot;onreadystatechange&quot;, function() {
					
					if (document.readyState === &quot;complete&quot;) {
						document.detachEvent(&quot;onreadystatechange&quot;, arguments.callee);
						loadedDom();
					}
				});
				

				window.attachEvent( &quot;onload&quot;, loadedDom );
				
				var toplevel = false;
				
				try {
					toplevel = window.frameElement == null;
				} catch(e) {}
	
				&#x2F;&#x2F;如果是IE并且不是iframe增加scrollCheck的判断
				if ( document.documentElement.doScroll &amp;&amp; toplevel ) {
					doScrollCheck();
				}
			}
		}

		&#x2F;&#x2F;	替代当前的方法，以便之后更高效的调用
		waitLoaded = _waitLoaded;
		return waitLoaded(callbackfn, feedback);
	}

	&#x2F;**
	 * waitLoaded方法的替代方法
	 *&#x2F;
	function _waitLoaded(callbackfn, feedback) {
		&#x2F;&#x2F;	如果存在feedback，那就设置其为loading状态
		if ( typeof feedback != &#x27;object&#x27; || feedback === null || !feedback.style ) {
			feedback = false;
		} else {
			feedback.style.cursor = &#x27;wait&#x27;;
		}
		
		var fn = domLoaded ? callbackfn : (function() {
			var args = [];
			for ( var i = 0, il = arguments.length; i &lt; il; i++ ) {
				args.push(arguments[i]);
			}
			if (domLoaded) {
				callbackfn.apply(this, args);
			} else {
				domFollowers.push( [ callbackfn, this, args.concat() ] );
			}
		});
		if ( feedback ) {
			fn = bindFeedback( fn, feedback );
		}
		return fn;
	}
	
	&#x2F;**
	 * 绑定feedback处理
	 *&#x2F;
	function bindFeedback( callbackfn, feedback ) {
		return function() {
			&#x2F;&#x2F;	如果还存在feedback，并且还是之前的鼠标样式，那就删除之
			var style;
			if ( feedback &amp;&amp; ( style = feedback.style ) &amp;&amp; style.cursor == &#x27;wait&#x27; ) {
				if ( style.removeAttribute ) style.removeAttribute( &#x27;cursor&#x27; );
				if ( style.removeProperty ) style.removeProperty( &#x27;cursor&#x27; );
			}
			
			var args = [];
			for ( var i = 0, il = arguments.length; i &lt; il; i++ ) {
				args.push(arguments[i]);
			}
			if (domLoaded) {
				callbackfn.apply(this, args);
			} else {
				domFollowers.push( [ callbackfn, this, args.concat() ] );
			}
		};
	}

	&#x2F;********************************************** Status Constant **********************************************&#x2F;

	var Status = {
		uninitialized:		0,		&#x2F;&#x2F;	未初始化：本包还未加载
		loading:			1,		&#x2F;&#x2F;	加载中：本包加载中
		loaded:				2,		&#x2F;&#x2F;	加载完成：本包加载完成，依赖包在加载中。判断条件：直接依赖包中至少有一个包的状态 &lt; 3
		interactive:		3,		&#x2F;&#x2F;	待用：直接依赖包至少都是待用状态。判断条件：直接依赖包没有一个包的状态 &lt; 3
		complete:			4		&#x2F;&#x2F;	可用：本包已经完全可用
	};

	&#x2F;********************************************** Require Class **********************************************&#x2F;

	&#x2F;**
	 * 描述一个依赖执行关系
	 * @param {Array} packages 依赖包的列表
	 * @param {function} callback 所有依赖包可用后的回调
	 *&#x2F;
	var Require = function(packages, callback) {
		this._callback = callback;
		this._count = packages.length;		&#x2F;&#x2F;	还未处于待用状态的依赖包的数量
	}

	&#x2F;**
	 * 设置又有一个包处于激活状态
	 * @return 是否所有的包都处于激活状态
	 * @type Boolean
	 *&#x2F;
	Require.prototype.interactiveOne = function() {
		&#x2F;&#x2F;	如果处于待用状态的依赖包的数量不超过1个，那就调用回调方法
		if (-- this._count &lt; 1) {
			&#x2F;&#x2F;	调用回调方法
			this._callback();

			&#x2F;&#x2F;	删除应用
			delete this._callback;
			delete this._count;

			return true;
		}
		return false;
	};

	&#x2F;**
	 * 设置处于待用状态的依赖包的数量
	 *&#x2F;
	Require.prototype.count = function(number) {
		this._count = number;
	};

	&#x2F;********************************************** Package Class **********************************************&#x2F;

	&#x2F;**
	 * Package类是kola系统的核心类，用于包的加载、管理和使用
	 * 
	 * @class Package
	 * @static
	 *&#x2F;
	var Package = {

		_followerMap: {},
		_statusMap: {},
		_contentMap: {},
		_requiresMap: {},
		_pathStatus: null,		&#x2F;&#x2F;	路径的状态信息

		&#x2F;**
		 * 请求包，然后执行回调
		 * @param {Array} packages 需要加载的包列表
		 * @param {function} callback 执行的回调方法
		 *&#x2F;
		require: function(packages, callback) {
			var require = new Require(packages, callback),
					unloadPackages=[],
					count = 0;

			&#x2F;&#x2F;	循环每个依赖包，如果包还未可用，那就在等待队列中增加当前的require对象
			each(packages, bind((function(require, Status) {
				var name = arguments[2],
					status = Package._status(name);

				&#x2F;&#x2F;	如果处于完全可用或可交互状态，那就不做处理
				if (status &gt;= Status.interactive) return;
				count ++;

				&#x2F;&#x2F;	在等待队列中增加当前的require对象
				var followers = this._followerMap[name];
				if (!followers) {
					followers = this._followerMap[name] = [];
				}
				followers.push(require);

				&#x2F;&#x2F;	如果包还未初始化，那就需要初始化
				if (status == Status.uninitialized) {
					unloadPackages.push(name);
				}
			}), this, require, Status));
								
			&#x2F;&#x2F;	如果依赖包都至少处于待用状态，那就直接激活可用
			if (count == 0) {
				callback();
			} else {
				require.count(count);
				each(unloadPackages, function(name) {
					Package._load(name);
				});
			}		
		},

		&#x2F;**
		 * 注册一个包
		 * @param {string} name 包的名称
		 * @param {Array} requires 依赖的包名列表，如果没有依赖的包，那可以设置成null
		 * @param {function} content 要注册的包的内容
		 *&#x2F;
		register: function(name, requires, content) {
			&#x2F;&#x2F;	如果已经加载成功，那就不再处理
			var status = this._status(name);
			if (status &gt;= Status.loaded) return null;

			&#x2F;&#x2F;	记录包和依赖的内容
			this._contentMap[name] = content;

			&#x2F;*
			此处为Plugin做修改
			this._requiresMap[name] = clone(requires);
			 *&#x2F;
			if ( requires === null ) {
				this._requiresMap[name] = null;
			} else {
				var list = clone( requires );
				for ( var i = list.length - 1; i &gt;= 0; i-- ) {
					var packageName = list[i];

					&#x2F;&#x2F;	FIXME: 暂时只检测简单的plugin，以后需要增强
					var array = packageName.split( &#x27;[&#x27; );
					&#x2F;&#x2F;	有插件
					if ( array.length == 2 ) {
						var plugins = trim( array[1].substring(0, array[1].length - 1) ).split(&#x27;,&#x27;);
						list[i] = {
							name: array[0],
							plugins: plugins
						};
						requires[i] = array[0];
						requires = requires.concat( plugins );
					}
				}
				this._requiresMap[name] = list;
			}


			&#x2F;&#x2F;	设置成加载完成状态
			this._status(name, Status.loaded);

			&#x2F;&#x2F;	根据依赖包的有无，进行不同的处理
			if (requires == null) {
				&#x2F;&#x2F;	如果包没有依赖的话，那就设置成可用状态
				this._interactive(name);
			} else {
				this.require(requires, bind(this._interactive, this, name));
			}
		},

		&#x2F;**
		 * 执行某个方法
		 * @param {Array} requires 依赖包列表
		 * @param {function} callback 回调方法
		 *&#x2F;
		exe: function(requires, callback) {
			&#x2F;&#x2F;	解析requires，主要是应付插件模式
			var list = clone( requires );
			for ( var i = list.length - 1; i &gt;= 0; i-- ) {
				var packageName = list[i];

				&#x2F;&#x2F;	FIXME: 暂时只检测简单的plugin，以后需要增强
				var array = packageName.split( &#x27;[&#x27; );
				&#x2F;&#x2F;	有插件
				if ( array.length == 2 ) {
					var plugins = array[1].substring(0, array[1].length - 1).split(&#x27;,&#x27;);
					list[i] = {
						name: array[0],
						plugins: plugins
					};
					requires[i] = array[0];
					requires = requires.concat( plugins );
				}
			}

			this.require(requires, bind((function() {
				&#x2F;&#x2F;	拿到所有的包对应的信息
				var params = [];
				
				each(list, bind((function(params, name) {
					&#x2F;&#x2F;	根据name的类型，进行不同的处理
					if ( typeof( name ) == &#x27;string&#x27; ) {
						&#x2F;&#x2F;	不是插件
						params.push(this._complete(name));
					} else {
						&#x2F;&#x2F;	是插件

						var packageObj = name,
							plugins = [],
							pluginPrototype = {},
							mainClass;

						&#x2F;&#x2F;	获取每个插件的结果
						each( packageObj.plugins, bind ( ( function(pluginName) {
							plugins.push( this._complete( pluginName ) );
						}), this ) );

						&#x2F;&#x2F;	获取主类的内容
						mainClass = this._complete( packageObj.name );
						if (mainClass.prototype.__ME) {
							pluginPrototype.__ME = mainClass.prototype.__ME;
						}

						plugins.unshift( pluginPrototype );
						plugins.unshift( mainClass );

						&#x2F;&#x2F;	创建新类
						var pluginClass = createClass.apply( this, plugins );

						&#x2F;&#x2F;	复制主类的静态属性和方法
						for ( var item in mainClass ) {
							pluginClass[item] = mainClass[item];
						}

						params.push( pluginClass );
					}

				}), this, params));

				&#x2F;&#x2F;	执行对应的回调方法
				callback.apply(window, params);
			}), this));
		},

		&#x2F;**
		 * 保存配置信息
		 * @param {Object} options 配置参数
		 *&#x2F;
		config: function(options) {
			&#x2F;&#x2F;	TODO: 这里应该是增量累加（相同覆盖）配置，现在先简单化处理
			this._config = options;
		},

		&#x2F;**
		 * 获取某个包所在的文件路径地址
		 * @param {String} name 包名
		 * @type String
		 * @return 文件url地址
		 *&#x2F;
		_path: function(name) {
			&#x2F;&#x2F;	获取、路径配置信息
			&#x2F;&#x2F;	没有配置信息，就创建一个空的
			var config = this._config;
			if (!config) {
				config = this._config = {};
			}
			var paths = config.paths;
			if (!paths) {
				paths = config.paths = {};
			}
			if (!paths._default) {
				&#x2F;&#x2F;	不存在路径配置，那就从当前url中获取配置
				
				var _default = &#x27;&#x27;;
				
				&#x2F;&#x2F;	循环每一个script，如果其src属性中存在&#x2F;kola&#x2F;Package.js，那就认为上层路径就是其默认地址
				var els = document.getElementsByTagName( &#x27;script&#x27; ),
					kolaFile = &#x27;kola&#x2F;Package.js&#x27;,
					length = kolaFile.length;
				for ( var i = 0, il = els.length; i &lt; il; i++ ) {
					var src, index;
					if ( typeof ( src = els[i].src ) == &#x27;string&#x27; &amp;&amp;
						( index = src.indexOf( kolaFile ) ) != -1 
					) {
						_default = src.substr( 0, index );
					}
				}
				
				&#x2F;&#x2F;	保存默认信息
				config.paths._default = _default;
			}

			var packs = name.split(&#x27;.&#x27;),
				unpathed = packs.concat();		&#x2F;&#x2F;	未被匹配的命名空间
			if ( packs.length == 0 ) return &#x27;&#x27;;

			&#x2F;&#x2F;	获取文件地址
			var files, file;
			if ( files = config.files ) {	&#x2F;&#x2F;	判断是否存在设置
				if ( typeof( file =  files[ name ] ) == &#x27;undefined&#x27; ) {		&#x2F;&#x2F;	判断是否存在该包的设置
					if (file = files[ packs.slice( 0, -1 ).join( &#x27;.&#x27; ) ]) {   &#x2F;&#x2F;	获取上层包的设置
						unpathed = unpathed.slice( 0, -2 );
					}

					&#x2F;&#x2F;	TODO: 这里应该可以做到不仅仅是上层，可以是更上层
				} else {
					unpathed = unpathed.slice( 0, -1 );
				}
			}

			&#x2F;&#x2F;	根据获得的文件的不同类型，进行不同的处理，以便于找到真正的文件名称
			switch ( typeof( file ) ) {

				&#x2F;&#x2F;	如果为数字，代表地址存在了一个数组中
				case &#x27;number&#x27;:
					file = files._urls[ file ];
					break;

				&#x2F;&#x2F;	如果为字符串，那就是地址
				case &#x27;string&#x27;:

					&#x2F;&#x2F;	TODO: 由于后端暂时无法改成上面的数字形式，这是一个临时的处理
					if ( file.length &lt; 3 ) {
						file = files._urls[ parseInt( file ) ];
					}

					break;

				&#x2F;&#x2F;	没有设置上层包
				default:
					&#x2F;&#x2F;	那就将包名直接转换为路径地址
					file = packs[ packs.length - 1 ] + &#x27;.js&#x27;;
					unpathed = unpathed.slice( 0, -1 );
			}

			&#x2F;&#x2F;	如果地址已经是最终的话，那就返回
			&#x2F;&#x2F;	TODO: 这里的判断不够严谨
			if ( file.indexOf( &#x27;http&#x27;) == 0 ) {
				return file;
			}

			&#x2F;&#x2F;	获取路径地址
			var paths = config.paths,		&#x2F;&#x2F;	路径配置信息
				path,
				i = 1,
				il = -unpathed.length;
			&#x2F;&#x2F;	逐个循环上级包，直到找到针对于大包的路径配置信息
			while ( ( --i ) &gt; il ) {
				if ( path = paths[ ( i == 0 ? unpathed.slice(0) : unpathed.slice( 0, i ) ).join( &#x27;.&#x27; ) ] ) {
					if ( i &lt; 0 ) {
						unpathed = unpathed.slice( unpathed.length + i );
					} else {
						unpathed = [];
					}
					break;
				}
			}
			&#x2F;&#x2F;	如果没有针对于大包的配置信息，那就获取默认的路径地址
			if ( !path ) {
				path = paths._default;
			}

			&#x2F;&#x2F;	返回路径加地址信息
			return path + ( unpathed.length &gt; 0 ? (unpathed.join( &#x27;&#x2F;&#x27; ) + &#x27;&#x2F;&#x27;) : &#x27;&#x27; ) + file;
		},

		&#x2F;**
		 * 把某个包设置成待用状态
		 *&#x2F;
		_interactive: function(name) {
			&#x2F;&#x2F;	设置包的状态
			this._status(name, Status.interactive);

			&#x2F;&#x2F;	如果该包不存在粉丝的话，那就不做后续处理
			var followers = this._followerMap[name];
			if (typeof(followers) != &#x27;object&#x27; || followers == null || followers.length == 0) return null;

			&#x2F;&#x2F;	循环所有粉丝，通知增加一个可交互者
			var waiters = [];
			each(followers, bind((function(waiters, require) {
				&#x2F;&#x2F;	如果某个require中所有等待包已经激活成功了，那就记录下这个require，因为之后需要从followers删除
				if (!require.interactiveOne()) {
					waiters.push(require);
				}
			}), this, waiters));

			&#x2F;&#x2F;	如果不存在当前包的等待者，那就清除相应的资源
			if (waiters.length == 0) {
				this._followerMap[name] = null;
			} else {
				this._followerMap[name] = waiters;
			}
		},

		&#x2F;**
		 * 把某个包设置成可用状态。调用这个方法的前提是，这个包已经至少处于待用状态
		 *&#x2F;
		_complete: function(name) {
			&#x2F;&#x2F;	如果已经是可用状态的话，那就返回包内容
			var map = this._contentMap,
				content = map[name];
			if (this._status(name) == Status.complete) {
				return content;
			}

			&#x2F;&#x2F;	包现在处于待用状态，需要将其变为可用状态

			&#x2F;&#x2F;	拿到所有依赖包的内容
			var requires = this._requiresMap[name],
				params = [];
			if (typeof(requires) == &#x27;object&#x27; &amp;&amp; requires instanceof Array &amp;&amp; requires.length &gt; 0) {
				each(requires, bind((function(params, name) {
					&#x2F;&#x2F;	根据该包的类型，来决定是否有使用插件，然后进行不同的处理

					if ( typeof( name ) == &#x27;string&#x27; ) {
						&#x2F;&#x2F;	不是插件
						params.push(this._complete(name));
					} else {
						&#x2F;&#x2F;	是插件

						var packageObj = name,
							plugins = [],
							pluginPrototype = {},
							mainClass;

						&#x2F;&#x2F;	获取每个插件的结果
						each( packageObj.plugins, bind ( ( function(pluginName) {
							plugins.push( this._complete( pluginName ) );
						}), this ) );

						&#x2F;&#x2F;	获取主类的内容
						mainClass = this._complete( packageObj.name );
						if (mainClass.prototype.__ME) {
							pluginPrototype.__ME = mainClass.prototype.__ME;
						}

						plugins.unshift( pluginPrototype );
						plugins.unshift( mainClass );

						&#x2F;&#x2F;	创建新类
						var pluginClass = createClass.apply( this, plugins );

						&#x2F;&#x2F;	复制主类的静态属性和方法
						for ( var item in mainClass ) {
							pluginClass[item] = mainClass[item];
						}

						params.push( pluginClass );
					}

				}), this, params));
			}

			&#x2F;&#x2F;	保存包的内容
			content = map[name] = typeof(content) == &#x27;function&#x27; ? content.apply(window, params) : content;

			&#x2F;&#x2F;	设置包为可用状态
			this._status(name, Status.complete);

			&#x2F;&#x2F;	如果这是一个类，那就设置类的名称
			if ( typeof( content ) == &#x27;function&#x27; &amp;&amp; content !== null &amp;&amp; content.__CLASS === true ) {
				content.__CLASS = name;
			}

			return content;
		},

		&#x2F;**
		 * 获取一个包的状态
		 * @param {string} name 包的名称
		 * @type number
		 * @return 包的当前状态
		 *&#x2F;
		&#x2F;**
		 * 设置一个包的状态
		 * @param {string} name 包的名称
		 * @param {number} [status] 包的状态
		 *&#x2F;
		_status: function(name, status) {
			if (typeof(status) == &#x27;undefined&#x27;) {
				status = this._statusMap[name];
				if (typeof(status) != &#x27;number&#x27;) {
					status = this._statusMap[name] = Status.uninitialized;
				}
				return status;
			} else {
				this._statusMap[name] = status;
			}
		},

		&#x2F;**
		 * 加载一个包
		 *&#x2F;
		_load: function(name) {
			&#x2F;&#x2F;	如果还未初始化路径信息的话，先进行该项初始化
			var pathStatus = this._pathStatus;
			if ( !pathStatus) {
				this._pathStatus = pathStatus = {};
				var scripts = document.getElementsByTagName(&#x27;script&#x27;);
				for ( var i = 0, il = scripts.length; i &lt; il; i++ ) {
					var src = scripts[i].src;
					if ( typeof( src ) == &#x27;string&#x27;) {
						pathStatus[src] = Status.loading;
					}
				}
			}

			&#x2F;&#x2F;	获取包所对应的文件路径及其加载状态
			var path = this._path(name),
				status = pathStatus[path];

			&#x2F;&#x2F;	如果还没有该文件的状态记录，那就加载该文件
			if (typeof(status) != &#x27;number&#x27;) {

				&#x2F;&#x2F;	先设置包的状态
				this._pathStatus[path] = Status.loading;
				this._status(name, Status.loading);
				
				&#x2F;&#x2F;	如果有设置不请求，那就不发送之，这样做一般是因为所有文件会直接注入
				if (this._config &amp;&amp; this._config.notRequest) return;

				&#x2F;&#x2F;	创建script节点，并设置相关属性
				var script = document.createElement(&#x27;script&#x27;);
				script.src = path;
				script.type = &#x27;text&#x2F;javascript&#x27;;
				
				&#x2F;&#x2F;	如果存在编码的配置，那就设置之
				var charset;
				if ((charset = this._config) &amp;&amp; (charset = charset.charset)) {
					script.charset = charset;
				}
				
				&#x2F;&#x2F;	设置加载错误后的处理方法	
				script.onerror = function() {
					&#x2F;&#x2F;	throw new Error(&quot;JS文件加载失败：&quot; + path);
					var message = &quot;can&#x27;t load js file：&quot; + path;
					if (window.Error) {
						throw new Error(message);
					} else {
						alert(message);
					}
					script.onerror = null;
				};

				&#x2F;&#x2F;	加载相应的js
				var head = document.getElementsByTagName(&#x27;head&#x27;)[0];
				head.appendChild(script);
				head = script = null;
				
			}
		}
	};

	&#x2F;*
	&#x2F;&#x2F;	注册kola.Package类
	Package.register( &#x27;kola.Package&#x27;, null, Package );
	*&#x2F;

	&#x2F;&#x2F;  记录正式kola方法之前的缓存
	var cache = window.kola ? window.kola._cache : null;


	&#x2F;**
	 * 注册一个kola包
	 * 
	 * @method kola
	 * @for window
	 * @param name {String} 要注册的包的包名
	 * @param requires {Null | String | Array&lt;String&gt;} 其所依赖的包，可以没有任何依赖，也可以直至为一个包名，也可以是包名数组
	 * @param creator {Function} 包实际内容的生成器，这个方法的返回值就是包的实际内容
	 *&#x2F;
	&#x2F;**
	 * 加载完指定的包之后，执行指定的方法
	 * 
	 * @method kola
	 * @for window
	 * @param requires {String | Array&lt;String&gt;} 其所依赖的包，也可以直至为一个包名，也可以是包名数组
	 * @param callbackfn {Function} 包加载完成后的方法
	 * @param [options] {Object} 配置参数
	 * 		@param afterDom {Boolean} 是否在DomContentLoaded之后再运行
	 *&#x2F;
	&#x2F;**
	 * 加载配置文件
	 * 
	 * @method kola
	 * @for window
	 * @param config {Object} kola系统的设置文件
	 *&#x2F;
	window.kola = function(a, b, c) {

		var ct = typeof(c);

		if (ct == &#x27;function&#x27;) {
			&#x2F;&#x2F;	这是要注册一个包
			Package.register(a, toArray(b), c);
		} else {
			&#x2F;&#x2F;	这是要执行一段代码

			var bt = typeof(b),
				length = bt == &#x27;undefined&#x27; ? 1 : (ct == &#x27;undefined&#x27; ? 2 : 3),
				callback = null,
				options = null,
				requires = null;

			&#x2F;&#x2F;	根据参数的数量，决定各个参数的含义
			switch (length) {
				case 1:

					if (typeof(a) == &#x27;function&#x27;) {
						&#x2F;&#x2F;	表示只有一个参数，而且这个参数就是要执行的方法
						callback = a;
					} else {
						&#x2F;&#x2F;  表示要进行配置
						Package.config(a);
						return;
					}

					&#x2F;&#x2F;	TODO: 这种情况暂时不予处理，预计不会出现使用情景
					break;
				case 2:
					&#x2F;&#x2F;	有两个参数，不过有两种情况，一种是依赖哪个包，执行某段程序，另一种是执行某个方法，还有一些配置参数

					if (bt == &#x27;object&#x27;) {
						&#x2F;&#x2F;	这是第二种情况：执行某个方法，还有一些配置参数
						callback = a;
						options = b;

						&#x2F;&#x2F;	TODO: 这种情况暂时不予处理，预计不会出现使用情景
					} else {
						&#x2F;&#x2F;	这是第一种情况：依赖哪个包，执行某段程序
						requires = a;
						callback = b;
					}
					break;
				case 3:
					&#x2F;&#x2F;	有三个参数，包括依赖包、执行代码和参数三部分
					requires = a;
					callback = b;
					options = c;

					break;
			}

			&#x2F;&#x2F;	根据不同的方法类型，进行不同的处理
			switch (typeof(callback)) {
				case &#x27;string&#x27;:
					&#x2F;&#x2F;	如果执行方法只是一段字符串，需要转成一个方法
					callback = new Function(callback);
				case &#x27;function&#x27;:
					&#x2F;&#x2F;	如果存在作用域，那就需要绑定
					if (!!options &amp;&amp; options.scope) {
						callback = bind(callback, options.scope);
						options.scope = null;
					}
					break;
			}
			
			&#x2F;&#x2F;	设定在domload之后触发，并且绑定feedback
			callback = waitLoaded(callback, options &amp;&amp; options.feedback);
			
			&#x2F;&#x2F;	拿到依赖包的数据，并转成符合的类型
			requires = toArray(requires);
			
			&#x2F;&#x2F;	根据是否存在依赖信息，进行不同的处理
			if (requires == null) {
				callback();
			} else {
				&#x2F;&#x2F;	调用包系统，执行相应的处理
				Package.exe(requires, callback);
			}
		}
	};

	kola.Package = Package;

	&#x2F;&#x2F;  如果kola替身已经收集到了要执行的方法，那就处理之
	if ( cache &amp;&amp; typeof( cache.length ) == &#x27;number&#x27; &amp;&amp; cache.length &gt; 0 ) {

		&#x2F;&#x2F;	找到所有是要进行配置的方法，预先执行
		for ( var i = 0, il = cache.length; i &lt; il; i++ ) {
			var args = cache[i];
			if ( args.length == 2 &amp;&amp; typeof( args[1] ) == &#x27;object&#x27; ) {
				&#x2F;&#x2F;	从待执行数组中删除当前的方法
				cache.splice( i-- , 1 );
				il--;

				&#x2F;&#x2F;	执行该项配置
				kola.apply( args.shift(), args );
			}
		}

		&#x2F;&#x2F;	如果还有存在于替身中的方法，那就放到下一个队列中执行
		if ( cache.length &gt; 0) {
			setTimeout( ( function() {
				for (i = 0, il = cache.length; i &lt; il; i++) {
					args = cache[i];
					kola.apply(args.shift(), args);
				}
			} ), 0 );
		}
	}

})();



    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
