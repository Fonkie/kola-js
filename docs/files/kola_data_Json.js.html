<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>kola\data\Json.js - kola</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="kola"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Array.html">Array</a></li>
            
                <li><a href="..&#x2F;classes/Class.html">Class</a></li>
            
                <li><a href="..&#x2F;classes/Function.html">Function</a></li>
            
                <li><a href="..&#x2F;classes/Package.html">Package</a></li>
            
                <li><a href="..&#x2F;classes/String.html">String</a></li>
            
                <li><a href="..&#x2F;classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/kola.html">kola</a></li>
            
                <li><a href="..&#x2F;modules/kola.lang.html">kola.lang</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: kola\data\Json.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
    @see https:&#x2F;&#x2F;github.com&#x2F;douglascrockford&#x2F;JSON-js
*&#x2F;

kola(&quot;kola.data.Json&quot;,[
    &quot;kola.bom.Browser&quot;
],function(Browser){
    if(Browser.IE){    
        var JSON={};

        function f(n) {
            &#x2F;&#x2F; Format integers to have at least two digits.
            return n &lt; 10 ? &#x27;0&#x27; + n : n;
        }

        if (typeof Date.prototype.toJSON !== &#x27;function&#x27;) {

            Date.prototype.toJSON = function (key) {

                return isFinite(this.valueOf())
                    ? this.getUTCFullYear()     + &#x27;-&#x27; +
                        f(this.getUTCMonth() + 1) + &#x27;-&#x27; +
                        f(this.getUTCDate())      + &#x27;T&#x27; +
                        f(this.getUTCHours())     + &#x27;:&#x27; +
                        f(this.getUTCMinutes())   + &#x27;:&#x27; +
                        f(this.getUTCSeconds())   + &#x27;Z&#x27;
                    : null;
            };

            String.prototype.toJSON      =
                Number.prototype.toJSON  =
                Boolean.prototype.toJSON = function (key) {
                    return this.valueOf();
                };
        }

        var cx = &#x2F;[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]&#x2F;g,
            escapable = &#x2F;[\\\&quot;\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]&#x2F;g,
            gap,
            indent,
            meta = {    &#x2F;&#x2F; table of character substitutions
                &#x27;\b&#x27;: &#x27;\\b&#x27;,
                &#x27;\t&#x27;: &#x27;\\t&#x27;,
                &#x27;\n&#x27;: &#x27;\\n&#x27;,
                &#x27;\f&#x27;: &#x27;\\f&#x27;,
                &#x27;\r&#x27;: &#x27;\\r&#x27;,
                &#x27;&quot;&#x27; : &#x27;\\&quot;&#x27;,
                &#x27;\\&#x27;: &#x27;\\\\&#x27;
            },
            rep;


        function quote(string) {

    &#x2F;&#x2F; If the string contains no control characters, no quote characters, and no
    &#x2F;&#x2F; backslash characters, then we can safely slap some quotes around it.
    &#x2F;&#x2F; Otherwise we must also replace the offending characters with safe escape
    &#x2F;&#x2F; sequences.

            escapable.lastIndex = 0;
            return escapable.test(string) ? &#x27;&quot;&#x27; + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === &#x27;string&#x27;
                    ? c
                    : &#x27;\\u&#x27; + (&#x27;0000&#x27; + a.charCodeAt(0).toString(16)).slice(-4);
            }) + &#x27;&quot;&#x27; : &#x27;&quot;&#x27; + string + &#x27;&quot;&#x27;;
        }


        function str(key, holder) {

    &#x2F;&#x2F; Produce a string from holder[key].

            var i,          &#x2F;&#x2F; The loop counter.
                k,          &#x2F;&#x2F; The member key.
                v,          &#x2F;&#x2F; The member value.
                length,
                mind = gap,
                partial,
                value = holder[key];

    &#x2F;&#x2F; If the value has a toJSON method, call it to obtain a replacement value.

            if (value &amp;&amp; typeof value === &#x27;object&#x27; &amp;&amp;
                    typeof value.toJSON === &#x27;function&#x27;) {
                value = value.toJSON(key);
            }

    &#x2F;&#x2F; If we were called with a replacer function, then call the replacer to
    &#x2F;&#x2F; obtain a replacement value.

            if (typeof rep === &#x27;function&#x27;) {
                value = rep.call(holder, key, value);
            }

    &#x2F;&#x2F; What happens next depends on the value&#x27;s type.

            switch (typeof value) {
            case &#x27;string&#x27;:
                return quote(value);

            case &#x27;number&#x27;:

    &#x2F;&#x2F; JSON numbers must be finite. Encode non-finite numbers as null.

                return isFinite(value) ? String(value) : &#x27;null&#x27;;

            case &#x27;boolean&#x27;:
            case &#x27;null&#x27;:

    &#x2F;&#x2F; If the value is a boolean or null, convert it to a string. Note:
    &#x2F;&#x2F; typeof null does not produce &#x27;null&#x27;. The case is included here in
    &#x2F;&#x2F; the remote chance that this gets fixed someday.

                return String(value);

    &#x2F;&#x2F; If the type is &#x27;object&#x27;, we might be dealing with an object or an array or
    &#x2F;&#x2F; null.

            case &#x27;object&#x27;:

    &#x2F;&#x2F; Due to a specification blunder in ECMAScript, typeof null is &#x27;object&#x27;,
    &#x2F;&#x2F; so watch out for that case.

                if (!value) {
                    return &#x27;null&#x27;;
                }

    &#x2F;&#x2F; Make an array to hold the partial results of stringifying this object value.

                gap += indent;
                partial = [];

    &#x2F;&#x2F; Is the value an array?

                if (Object.prototype.toString.apply(value) === &#x27;[object Array]&#x27;) {

    &#x2F;&#x2F; The value is an array. Stringify every element. Use null as a placeholder
    &#x2F;&#x2F; for non-JSON values.

                    length = value.length;
                    for (i = 0; i &lt; length; i += 1) {
                        partial[i] = str(i, value) || &#x27;null&#x27;;
                    }

    &#x2F;&#x2F; Join all of the elements together, separated with commas, and wrap them in
    &#x2F;&#x2F; brackets.

                    v = partial.length === 0
                        ? &#x27;[]&#x27;
                        : gap
                        ? &#x27;[\n&#x27; + gap + partial.join(&#x27;,\n&#x27; + gap) + &#x27;\n&#x27; + mind + &#x27;]&#x27;
                        : &#x27;[&#x27; + partial.join(&#x27;,&#x27;) + &#x27;]&#x27;;
                    gap = mind;
                    return v;
                }

    &#x2F;&#x2F; If the replacer is an array, use it to select the members to be stringified.

                if (rep &amp;&amp; typeof rep === &#x27;object&#x27;) {
                    length = rep.length;
                    for (i = 0; i &lt; length; i += 1) {
                        if (typeof rep[i] === &#x27;string&#x27;) {
                            k = rep[i];
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? &#x27;: &#x27; : &#x27;:&#x27;) + v);
                            }
                        }
                    }
                } else {

    &#x2F;&#x2F; Otherwise, iterate through all of the keys in the object.

                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = str(k, value);
                            if (v) {
                                partial.push(quote(k) + (gap ? &#x27;: &#x27; : &#x27;:&#x27;) + v);
                            }
                        }
                    }
                }

    &#x2F;&#x2F; Join all of the member texts together, separated with commas,
    &#x2F;&#x2F; and wrap them in braces.

                v = partial.length === 0
                    ? &#x27;{}&#x27;
                    : gap
                    ? &#x27;{\n&#x27; + gap + partial.join(&#x27;,\n&#x27; + gap) + &#x27;\n&#x27; + mind + &#x27;}&#x27;
                    : &#x27;{&#x27; + partial.join(&#x27;,&#x27;) + &#x27;}&#x27;;
                gap = mind;
                return v;
            }
        }

&#x2F;&#x2F; If the JSON object does not yet have a stringify method, give it one.

        JSON.stringify = function (value, replacer, space) {

&#x2F;&#x2F; The stringify method takes a value and an optional replacer, and an optional
&#x2F;&#x2F; space parameter, and returns a JSON text. The replacer can be a function
&#x2F;&#x2F; that can replace values, or an array of strings that will select the keys.
&#x2F;&#x2F; A default replacer method can be provided. Use of the space parameter can
&#x2F;&#x2F; produce text that is more easily readable.

            var i;
            gap = &#x27;&#x27;;
            indent = &#x27;&#x27;;

&#x2F;&#x2F; If the space parameter is a number, make an indent string containing that
&#x2F;&#x2F; many spaces.

            if (typeof space === &#x27;number&#x27;) {
                for (i = 0; i &lt; space; i += 1) {
                    indent += &#x27; &#x27;;
                }

&#x2F;&#x2F; If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === &#x27;string&#x27;) {
                indent = space;
            }

&#x2F;&#x2F; If there is a replacer, it must be a function or an array.
&#x2F;&#x2F; Otherwise, throw an error.

            rep = replacer;
            if (replacer &amp;&amp; typeof replacer !== &#x27;function&#x27; &amp;&amp;
                    (typeof replacer !== &#x27;object&#x27; ||
                    typeof replacer.length !== &#x27;number&#x27;)) {
                throw new Error(&#x27;JSON.stringify&#x27;);
            }

&#x2F;&#x2F; Make a fake root object containing our value under the key of &#x27;&#x27;.
&#x2F;&#x2F; Return the result of stringifying the value.

            return str(&#x27;&#x27;, {&#x27;&#x27;: value});
        };


&#x2F;&#x2F; If the JSON object does not yet have a parse method, give it one.

        JSON.parse = function (text, reviver) {

&#x2F;&#x2F; The parse method takes a text and an optional reviver function, and returns
&#x2F;&#x2F; a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

&#x2F;&#x2F; The walk method is used to recursively walk the resulting structure so
&#x2F;&#x2F; that modifications can be made.

                var k, v, value = holder[key];
                if (value &amp;&amp; typeof value === &#x27;object&#x27;) {
                    for (k in value) {
                        if (Object.prototype.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


&#x2F;&#x2F; Parsing happens in four stages. In the first stage, we replace certain
&#x2F;&#x2F; Unicode characters with escape sequences. JavaScript handles many characters
&#x2F;&#x2F; incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return &#x27;\\u&#x27; +
                        (&#x27;0000&#x27; + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

&#x2F;&#x2F; In the second stage, we run the text against regular expressions that look
&#x2F;&#x2F; for non-JSON patterns. We are especially concerned with &#x27;()&#x27; and &#x27;new&#x27;
&#x2F;&#x2F; because they can cause invocation, and &#x27;=&#x27; because it can cause mutation.
&#x2F;&#x2F; But just to be safe, we want to reject all unexpected forms.

&#x2F;&#x2F; We split the second stage into 4 regexp operations in order to work around
&#x2F;&#x2F; crippling inefficiencies in IE&#x27;s and Safari&#x27;s regexp engines. First we
&#x2F;&#x2F; replace the JSON backslash pairs with &#x27;@&#x27; (a non-JSON character). Second, we
&#x2F;&#x2F; replace all simple value tokens with &#x27;]&#x27; characters. Third, we delete all
&#x2F;&#x2F; open brackets that follow a colon or comma or that begin the text. Finally,
&#x2F;&#x2F; we look to see that the remaining characters are only whitespace or &#x27;]&#x27; or
&#x2F;&#x2F; &#x27;,&#x27; or &#x27;:&#x27; or &#x27;{&#x27; or &#x27;}&#x27;. If that is so, then the text is safe for eval.

            if (&#x2F;^[\],:{}\s]*$&#x2F;
                    .test(text.replace(&#x2F;\\(?:[&quot;\\\&#x2F;bfnrt]|u[0-9a-fA-F]{4})&#x2F;g, &#x27;@&#x27;)
                        .replace(&#x2F;&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?&#x2F;g, &#x27;]&#x27;)
                        .replace(&#x2F;(?:^|:|,)(?:\s*\[)+&#x2F;g, &#x27;&#x27;))) {

&#x2F;&#x2F; In the third stage we use the eval function to compile the text into a
&#x2F;&#x2F; JavaScript structure. The &#x27;{&#x27; operator is subject to a syntactic ambiguity
&#x2F;&#x2F; in JavaScript: it can begin a block or an object literal. We wrap the text
&#x2F;&#x2F; in parens to eliminate the ambiguity.

                j = eval(&#x27;(&#x27; + text + &#x27;)&#x27;);

&#x2F;&#x2F; In the optional fourth stage, we recursively walk the new structure, passing
&#x2F;&#x2F; each name&#x2F;value pair to a reviver function for possible transformation.

                return typeof reviver === &#x27;function&#x27;
                    ? walk({&#x27;&#x27;: j}, &#x27;&#x27;)
                    : j;
            }

&#x2F;&#x2F; If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError(&#x27;JSON.parse&#x27;);
        };
        return JSON;
    }else{
        return window.JSON;
    }
});




    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
