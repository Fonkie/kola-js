<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>kola\css\Selector.js - kola</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="kola"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Array.html">Array</a></li>
            
                <li><a href="..&#x2F;classes/Class.html">Class</a></li>
            
                <li><a href="..&#x2F;classes/Function.html">Function</a></li>
            
                <li><a href="..&#x2F;classes/Package.html">Package</a></li>
            
                <li><a href="..&#x2F;classes/String.html">String</a></li>
            
                <li><a href="..&#x2F;classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/kola.html">kola</a></li>
            
                <li><a href="..&#x2F;modules/kola.lang.html">kola.lang</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: kola\css\Selector.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * @fileOverview kola.css.Selector css选择器类。使用Sizzle CSS Selector Engine，More information: http:&#x2F;&#x2F;sizzlejs.com&#x2F;
 *&#x2F;


kola(&#x27;kola.css.Selector&#x27;,
	null, 
	function() {
	
	&#x2F;********************************************** 类定义 **********************************************&#x2F;

	var chunker = &#x2F;((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|[&#x27;&quot;][^&#x27;&quot;]*[&#x27;&quot;]|[^\[\]&#x27;&quot;]+)+\]|\\.|[^ &gt;+~,(\[\\]+)+|[&gt;+~])(\s*,\s*)?((?:.|\r|\n)*)&#x2F;g,
		done = 0,
		toString = Object.prototype.toString,
		hasDuplicate = false,
		baseHasDuplicate = true;

	&#x2F;&#x2F; Here we check if the JavaScript engine is using some sort of
	&#x2F;&#x2F; optimization where it does not always call our comparision
	&#x2F;&#x2F; function. If that is the case, discard the hasDuplicate value.
	&#x2F;&#x2F;   Thus far that includes Google Chrome.
	[0, 0].sort(function() {
		baseHasDuplicate = false;
		return 0;
	});

	var Sizzle = function( selector, context, results, seed ) {
		results = results || [];
		context = context || document;

		var origContext = context;

		if ( context.nodeType !== 1 &amp;&amp; context.nodeType !== 9 ) {
			return [];
		}

		if ( !selector || typeof selector !== &quot;string&quot; ) {
			return results;
		}

		var m, set, checkSet, extra, ret, cur, pop, i,
			prune = true,
			contextXML = Sizzle.isXML( context ),
			parts = [],
			soFar = selector;

		&#x2F;&#x2F; Reset the position of the chunker regexp (start from head)
		do {
			chunker.exec( &quot;&quot; );
			m = chunker.exec( soFar );

			if ( m ) {
				soFar = m[3];

				parts.push( m[1] );

				if ( m[2] ) {
					extra = m[3];
					break;
				}
			}
		} while ( m );

		if ( parts.length &gt; 1 &amp;&amp; origPOS.exec( selector ) ) {

			if ( parts.length === 2 &amp;&amp; Expr.relative[ parts[0] ] ) {
				set = posProcess( parts[0] + parts[1], context );

			} else {
				set = Expr.relative[ parts[0] ] ?
					[ context ] :
					Sizzle( parts.shift(), context );

				while ( parts.length ) {
					selector = parts.shift();

					if ( Expr.relative[ selector ] ) {
						selector += parts.shift();
					}

					set = posProcess( selector, set );
				}
			}

		} else {
			&#x2F;&#x2F; Take a shortcut and set the context if the root selector is an ID
			&#x2F;&#x2F; (but not if it&#x27;ll be faster if the inner selector is an ID)
			if ( !seed &amp;&amp; parts.length &gt; 1 &amp;&amp; context.nodeType === 9 &amp;&amp; !contextXML &amp;&amp;
					Expr.match.ID.test(parts[0]) &amp;&amp; !Expr.match.ID.test(parts[parts.length - 1]) ) {

				ret = Sizzle.find( parts.shift(), context, contextXML );
				context = ret.expr ?
					Sizzle.filter( ret.expr, ret.set )[0] :
					ret.set[0];
			}

			if ( context ) {
				ret = seed ?
					{ expr: parts.pop(), set: makeArray(seed) } :
					Sizzle.find( parts.pop(), parts.length === 1 &amp;&amp; (parts[0] === &quot;~&quot; || parts[0] === &quot;+&quot;) &amp;&amp; context.parentNode ? context.parentNode : context, contextXML );

				set = ret.expr ?
					Sizzle.filter( ret.expr, ret.set ) :
					ret.set;

				if ( parts.length &gt; 0 ) {
					checkSet = makeArray( set );

				} else {
					prune = false;
				}

				while ( parts.length ) {
					cur = parts.pop();
					pop = cur;

					if ( !Expr.relative[ cur ] ) {
						cur = &quot;&quot;;
					} else {
						pop = parts.pop();
					}

					if ( pop == null ) {
						pop = context;
					}

					Expr.relative[ cur ]( checkSet, pop, contextXML );
				}

			} else {
				checkSet = parts = [];
			}
		}

		if ( !checkSet ) {
			checkSet = set;
		}

		if ( !checkSet ) {
			Sizzle.error( cur || selector );
		}

		if ( toString.call(checkSet) === &quot;[object Array]&quot; ) {
			if ( !prune ) {
				results.push.apply( results, checkSet );

			} else if ( context &amp;&amp; context.nodeType === 1 ) {
				for ( i = 0; checkSet[i] != null; i++ ) {
					if ( checkSet[i] &amp;&amp; (checkSet[i] === true || checkSet[i].nodeType === 1 &amp;&amp; Sizzle.contains(context, checkSet[i])) ) {
						results.push( set[i] );
					}
				}

			} else {
				for ( i = 0; checkSet[i] != null; i++ ) {
					if ( checkSet[i] &amp;&amp; checkSet[i].nodeType === 1 ) {
						results.push( set[i] );
					}
				}
			}

		} else {
			makeArray( checkSet, results );
		}

		if ( extra ) {
			Sizzle( extra, origContext, results, seed );
			Sizzle.uniqueSort( results );
		}

		return results;
	};

	Sizzle.uniqueSort = function( results ) {
		if ( sortOrder ) {
			hasDuplicate = baseHasDuplicate;
			results.sort( sortOrder );

			if ( hasDuplicate ) {
				for ( var i = 1; i &lt; results.length; i++ ) {
					if ( results[i] === results[ i - 1 ] ) {
						results.splice( i--, 1 );
					}
				}
			}
		}

		return results;
	};

	Sizzle.matches = function( expr, set ) {
		return Sizzle( expr, null, null, set );
	};

	Sizzle.matchesSelector = function( node, expr ) {
		return Sizzle( expr, null, null, [node] ).length &gt; 0;
	};

	Sizzle.find = function( expr, context, isXML ) {
		var set;

		if ( !expr ) {
			return [];
		}

		for ( var i = 0, l = Expr.order.length; i &lt; l; i++ ) {
			var match,
				type = Expr.order[i];

			if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
				var left = match[1];
				match.splice( 1, 1 );

				if ( left.substr( left.length - 1 ) !== &quot;\\&quot; ) {
					match[1] = (match[1] || &quot;&quot;).replace(&#x2F;\\&#x2F;g, &quot;&quot;);
					set = Expr.find[ type ]( match, context, isXML );

					if ( set != null ) {
						expr = expr.replace( Expr.match[ type ], &quot;&quot; );
						break;
					}
				}
			}
		}

		if ( !set ) {
			set = typeof context.getElementsByTagName !== &quot;undefined&quot; ?
				context.getElementsByTagName( &quot;*&quot; ) :
				[];
		}

		return { set: set, expr: expr };
	};

	Sizzle.filter = function( expr, set, inplace, not ) {
		var match, anyFound,
			old = expr,
			result = [],
			curLoop = set,
			isXMLFilter = set &amp;&amp; set[0] &amp;&amp; Sizzle.isXML( set[0] );

		while ( expr &amp;&amp; set.length ) {
			for ( var type in Expr.filter ) {
				if ( (match = Expr.leftMatch[ type ].exec( expr )) != null &amp;&amp; match[2] ) {
					var found, item,
						filter = Expr.filter[ type ],
						left = match[1];

					anyFound = false;

					match.splice(1,1);

					if ( left.substr( left.length - 1 ) === &quot;\\&quot; ) {
						continue;
					}

					if ( curLoop === result ) {
						result = [];
					}

					if ( Expr.preFilter[ type ] ) {
						match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

						if ( !match ) {
							anyFound = found = true;

						} else if ( match === true ) {
							continue;
						}
					}

					if ( match ) {
						for ( var i = 0; (item = curLoop[i]) != null; i++ ) {
							if ( item ) {
								found = filter( item, match, i, curLoop );
								var pass = not ^ !!found;

								if ( inplace &amp;&amp; found != null ) {
									if ( pass ) {
										anyFound = true;

									} else {
										curLoop[i] = false;
									}

								} else if ( pass ) {
									result.push( item );
									anyFound = true;
								}
							}
						}
					}

					if ( found !== undefined ) {
						if ( !inplace ) {
							curLoop = result;
						}

						expr = expr.replace( Expr.match[ type ], &quot;&quot; );

						if ( !anyFound ) {
							return [];
						}

						break;
					}
				}
			}

			&#x2F;&#x2F; Improper expression
			if ( expr === old ) {
				if ( anyFound == null ) {
					Sizzle.error( expr );

				} else {
					break;
				}
			}

			old = expr;
		}

		return curLoop;
	};

	Sizzle.error = function( msg ) {
		throw &quot;Syntax error, unrecognized expression: &quot; + msg;
	};

	var Expr = Sizzle.selectors = {
		order: [ &quot;ID&quot;, &quot;NAME&quot;, &quot;TAG&quot; ],

		match: {
			ID: &#x2F;#((?:[\w\u00c0-\uFFFF\-]|\\.)+)&#x2F;,
			CLASS: &#x2F;\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)&#x2F;,
			NAME: &#x2F;\[name=[&#x27;&quot;]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)[&#x27;&quot;]*\]&#x2F;,
			ATTR: &#x2F;\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:([&#x27;&quot;])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]&#x2F;,
			TAG: &#x2F;^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)&#x2F;,
			CHILD: &#x2F;:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?&#x2F;,
			POS: &#x2F;:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)&#x2F;,
			PSEUDO: &#x2F;:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\(([&#x27;&quot;]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?&#x2F;
		},

		leftMatch: {},

		attrMap: {
			&quot;class&quot;: &quot;className&quot;,
			&quot;for&quot;: &quot;htmlFor&quot;
		},

		attrHandle: {
			href: function( elem ) {
				return elem.getAttribute( &quot;href&quot; );
			}
		},

		relative: {
			&quot;+&quot;: function(checkSet, part){
				var isPartStr = typeof part === &quot;string&quot;,
					isTag = isPartStr &amp;&amp; !&#x2F;\W&#x2F;.test( part ),
					isPartStrNotTag = isPartStr &amp;&amp; !isTag;

				if ( isTag ) {
					part = part.toLowerCase();
				}

				for ( var i = 0, l = checkSet.length, elem; i &lt; l; i++ ) {
					if ( (elem = checkSet[i]) ) {
						while ( (elem = elem.previousSibling) &amp;&amp; elem.nodeType !== 1 ) {}

						checkSet[i] = isPartStrNotTag || elem &amp;&amp; elem.nodeName.toLowerCase() === part ?
							elem || false :
							elem === part;
					}
				}

				if ( isPartStrNotTag ) {
					Sizzle.filter( part, checkSet, true );
				}
			},

			&quot;&gt;&quot;: function( checkSet, part ) {
				var elem,
					isPartStr = typeof part === &quot;string&quot;,
					i = 0,
					l = checkSet.length;

				if ( isPartStr &amp;&amp; !&#x2F;\W&#x2F;.test( part ) ) {
					part = part.toLowerCase();

					for ( ; i &lt; l; i++ ) {
						elem = checkSet[i];

						if ( elem ) {
							var parent = elem.parentNode;
							checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
						}
					}

				} else {
					for ( ; i &lt; l; i++ ) {
						elem = checkSet[i];

						if ( elem ) {
							checkSet[i] = isPartStr ?
								elem.parentNode :
								elem.parentNode === part;
						}
					}

					if ( isPartStr ) {
						Sizzle.filter( part, checkSet, true );
					}
				}
			},

			&quot;&quot;: function(checkSet, part, isXML){
				var nodeCheck,
					doneName = done++,
					checkFn = dirCheck;

				if ( typeof part === &quot;string&quot; &amp;&amp; !&#x2F;\W&#x2F;.test(part) ) {
					part = part.toLowerCase();
					nodeCheck = part;
					checkFn = dirNodeCheck;
				}

				checkFn( &quot;parentNode&quot;, part, doneName, checkSet, nodeCheck, isXML );
			},

			&quot;~&quot;: function( checkSet, part, isXML ) {
				var nodeCheck,
					doneName = done++,
					checkFn = dirCheck;

				if ( typeof part === &quot;string&quot; &amp;&amp; !&#x2F;\W&#x2F;.test( part ) ) {
					part = part.toLowerCase();
					nodeCheck = part;
					checkFn = dirNodeCheck;
				}

				checkFn( &quot;previousSibling&quot;, part, doneName, checkSet, nodeCheck, isXML );
			}
		},

		find: {
			ID: function( match, context, isXML ) {
				if ( typeof context.getElementById !== &quot;undefined&quot; &amp;&amp; !isXML ) {
					var m = context.getElementById(match[1]);
					&#x2F;&#x2F; Check parentNode to catch when Blackberry 4.6 returns
					&#x2F;&#x2F; nodes that are no longer in the document #6963
					return m &amp;&amp; m.parentNode ? [m] : [];
				}
			},

			NAME: function( match, context ) {
				if ( typeof context.getElementsByName !== &quot;undefined&quot; ) {
					var ret = [],
						results = context.getElementsByName( match[1] );

					for ( var i = 0, l = results.length; i &lt; l; i++ ) {
						if ( results[i].getAttribute(&quot;name&quot;) === match[1] ) {
							ret.push( results[i] );
						}
					}

					return ret.length === 0 ? null : ret;
				}
			},

			TAG: function( match, context ) {
				if ( typeof context.getElementsByTagName !== &quot;undefined&quot; ) {
					return context.getElementsByTagName( match[1] );
				}
			}
		},
		preFilter: {
			CLASS: function( match, curLoop, inplace, result, not, isXML ) {
				match = &quot; &quot; + match[1].replace(&#x2F;\\&#x2F;g, &quot;&quot;) + &quot; &quot;;

				if ( isXML ) {
					return match;
				}

				for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
					if ( elem ) {
						if ( not ^ (elem.className &amp;&amp; (&quot; &quot; + elem.className + &quot; &quot;).replace(&#x2F;[\t\n\r]&#x2F;g, &quot; &quot;).indexOf(match) &gt;= 0) ) {
							if ( !inplace ) {
								result.push( elem );
							}

						} else if ( inplace ) {
							curLoop[i] = false;
						}
					}
				}

				return false;
			},

			ID: function( match ) {
				return match[1].replace(&#x2F;\\&#x2F;g, &quot;&quot;);
			},

			TAG: function( match, curLoop ) {
				return match[1].toLowerCase();
			},

			CHILD: function( match ) {
				if ( match[1] === &quot;nth&quot; ) {
					if ( !match[2] ) {
						Sizzle.error( match[0] );
					}

					match[2] = match[2].replace(&#x2F;^\+|\s*&#x2F;g, &#x27;&#x27;);

					&#x2F;&#x2F; parse equations like &#x27;even&#x27;, &#x27;odd&#x27;, &#x27;5&#x27;, &#x27;2n&#x27;, &#x27;3n+2&#x27;, &#x27;4n-1&#x27;, &#x27;-n+6&#x27;
					var test = &#x2F;(-?)(\d*)(?:n([+\-]?\d*))?&#x2F;.exec(
						match[2] === &quot;even&quot; &amp;&amp; &quot;2n&quot; || match[2] === &quot;odd&quot; &amp;&amp; &quot;2n+1&quot; ||
						!&#x2F;\D&#x2F;.test( match[2] ) &amp;&amp; &quot;0n+&quot; + match[2] || match[2]);

					&#x2F;&#x2F; calculate the numbers (first)n+(last) including if they are negative
					match[2] = (test[1] + (test[2] || 1)) - 0;
					match[3] = test[3] - 0;
				}
				else if ( match[2] ) {
					Sizzle.error( match[0] );
				}

				&#x2F;&#x2F; TODO: Move to normal caching system
				match[0] = done++;

				return match;
			},

			ATTR: function( match, curLoop, inplace, result, not, isXML ) {
				var name = match[1] = match[1].replace(&#x2F;\\&#x2F;g, &quot;&quot;);

				if ( !isXML &amp;&amp; Expr.attrMap[name] ) {
					match[1] = Expr.attrMap[name];
				}

				&#x2F;&#x2F; Handle if an un-quoted value was used
				match[4] = ( match[4] || match[5] || &quot;&quot; ).replace(&#x2F;\\&#x2F;g, &quot;&quot;);

				if ( match[2] === &quot;~=&quot; ) {
					match[4] = &quot; &quot; + match[4] + &quot; &quot;;
				}

				return match;
			},

			PSEUDO: function( match, curLoop, inplace, result, not ) {
				if ( match[1] === &quot;not&quot; ) {
					&#x2F;&#x2F; If we&#x27;re dealing with a complex expression, or a simple one
					if ( ( chunker.exec(match[3]) || &quot;&quot; ).length &gt; 1 || &#x2F;^\w&#x2F;.test(match[3]) ) {
						match[3] = Sizzle(match[3], null, null, curLoop);

					} else {
						var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

						if ( !inplace ) {
							result.push.apply( result, ret );
						}

						return false;
					}

				} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
					return true;
				}

				return match;
			},

			POS: function( match ) {
				match.unshift( true );

				return match;
			}
		},

		filters: {
			enabled: function( elem ) {
				return elem.disabled === false &amp;&amp; elem.type !== &quot;hidden&quot;;
			},

			disabled: function( elem ) {
				return elem.disabled === true;
			},

			checked: function( elem ) {
				return elem.checked === true;
			},

			selected: function( elem ) {
				&#x2F;&#x2F; Accessing this property makes selected-by-default
				&#x2F;&#x2F; options in Safari work properly
				elem.parentNode.selectedIndex;

				return elem.selected === true;
			},

			parent: function( elem ) {
				return !!elem.firstChild;
			},

			empty: function( elem ) {
				return !elem.firstChild;
			},

			has: function( elem, i, match ) {
				return !!Sizzle( match[3], elem ).length;
			},

			header: function( elem ) {
				return (&#x2F;h\d&#x2F;i).test( elem.nodeName );
			},

			text: function( elem ) {
				return &quot;text&quot; === elem.type;
			},
			radio: function( elem ) {
				return &quot;radio&quot; === elem.type;
			},

			checkbox: function( elem ) {
				return &quot;checkbox&quot; === elem.type;
			},

			file: function( elem ) {
				return &quot;file&quot; === elem.type;
			},
			password: function( elem ) {
				return &quot;password&quot; === elem.type;
			},

			submit: function( elem ) {
				return &quot;submit&quot; === elem.type;
			},

			image: function( elem ) {
				return &quot;image&quot; === elem.type;
			},

			reset: function( elem ) {
				return &quot;reset&quot; === elem.type;
			},

			button: function( elem ) {
				return &quot;button&quot; === elem.type || elem.nodeName.toLowerCase() === &quot;button&quot;;
			},

			input: function( elem ) {
				return (&#x2F;input|select|textarea|button&#x2F;i).test( elem.nodeName );
			}
		},
		setFilters: {
			first: function( elem, i ) {
				return i === 0;
			},

			last: function( elem, i, match, array ) {
				return i === array.length - 1;
			},

			even: function( elem, i ) {
				return i % 2 === 0;
			},

			odd: function( elem, i ) {
				return i % 2 === 1;
			},

			lt: function( elem, i, match ) {
				return i &lt; match[3] - 0;
			},

			gt: function( elem, i, match ) {
				return i &gt; match[3] - 0;
			},

			nth: function( elem, i, match ) {
				return match[3] - 0 === i;
			},

			eq: function( elem, i, match ) {
				return match[3] - 0 === i;
			}
		},
		filter: {
			PSEUDO: function( elem, match, i, array ) {
				var name = match[1],
					filter = Expr.filters[ name ];

				if ( filter ) {
					return filter( elem, i, match, array );

				} else if ( name === &quot;contains&quot; ) {
					return (elem.textContent || elem.innerText || Sizzle.getText([ elem ]) || &quot;&quot;).indexOf(match[3]) &gt;= 0;

				} else if ( name === &quot;not&quot; ) {
					var not = match[3];

					for ( var j = 0, l = not.length; j &lt; l; j++ ) {
						if ( not[j] === elem ) {
							return false;
						}
					}

					return true;

				} else {
					Sizzle.error( name );
				}
			},

			CHILD: function( elem, match ) {
				var type = match[1],
					node = elem;

				switch ( type ) {
					case &quot;only&quot;:
					case &quot;first&quot;:
						while ( (node = node.previousSibling) )	 {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						if ( type === &quot;first&quot; ) {
							return true;
						}

						node = elem;

					case &quot;last&quot;:
						while ( (node = node.nextSibling) )	 {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						return true;

					case &quot;nth&quot;:
						var first = match[2],
							last = match[3];

						if ( first === 1 &amp;&amp; last === 0 ) {
							return true;
						}

						var doneName = match[0],
							parent = elem.parentNode;

						if ( parent &amp;&amp; (parent.sizcache !== doneName || !elem.nodeIndex) ) {
							var count = 0;

							for ( node = parent.firstChild; node; node = node.nextSibling ) {
								if ( node.nodeType === 1 ) {
									node.nodeIndex = ++count;
								}
							}

							parent.sizcache = doneName;
						}

						var diff = elem.nodeIndex - last;

						if ( first === 0 ) {
							return diff === 0;

						} else {
							return ( diff % first === 0 &amp;&amp; diff &#x2F; first &gt;= 0 );
						}
				}
			},

			ID: function( elem, match ) {
				return elem.nodeType === 1 &amp;&amp; elem.getAttribute(&quot;id&quot;) === match;
			},

			TAG: function( elem, match ) {
				return (match === &quot;*&quot; &amp;&amp; elem.nodeType === 1) || elem.nodeName.toLowerCase() === match;
			},

			CLASS: function( elem, match ) {
				return (&quot; &quot; + (elem.className || elem.getAttribute(&quot;class&quot;)) + &quot; &quot;)
					.indexOf( match ) &gt; -1;
			},

			ATTR: function( elem, match ) {
				var name = match[1],
					result = Expr.attrHandle[ name ] ?
						Expr.attrHandle[ name ]( elem ) :
						elem[ name ] != null ?
							elem[ name ] :
							elem.getAttribute( name ),
					value = result + &quot;&quot;,
					type = match[2],
					check = match[4];

				&#x2F;**
				 * 杰华@2011-7-14
				 * 下边这段代码，是解决ie下不能识别 *[ATTR]选择器的问题，貌似没有针对 [ATTR]进行判断和处理
				 *&#x2F;
				if ( ( typeof type == &#x27;undefined&#x27; || type == &quot;&quot; ) &amp;&amp; result !== null ) {
					return true;
				}

				return result == null ?
					type === &quot;!=&quot; :
					type === &quot;=&quot; ?
						value === check :
						type === &quot;*=&quot; ?
							value.indexOf(check) &gt;= 0 :
							type === &quot;~=&quot; ?
								(&quot; &quot; + value + &quot; &quot;).indexOf(check) &gt;= 0 :
								!check ?
									value &amp;&amp; result !== false :
									type === &quot;!=&quot; ?
										value !== check :
										type === &quot;^=&quot; ?
											value.indexOf(check) === 0 :
											type === &quot;$=&quot; ?
												value.substr(value.length - check.length) === check :
												type === &quot;|=&quot; ?
													value === check || value.substr(0, check.length + 1) === check + &quot;-&quot; :
													false;
			},

			POS: function( elem, match, i, array ) {
				var name = match[2],
					filter = Expr.setFilters[ name ];

				if ( filter ) {
					return filter( elem, i, match, array );
				}
			}
		}
	};

	var origPOS = Expr.match.POS,
		fescape = function(all, num){
			return &quot;\\&quot; + (num - 0 + 1);
		};

	for ( var type in Expr.match ) {
		Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (&#x2F;(?![^\[]*\])(?![^\(]*\))&#x2F;.source) );
		Expr.leftMatch[ type ] = new RegExp( &#x2F;(^(?:.|\r|\n)*?)&#x2F;.source + Expr.match[ type ].source.replace(&#x2F;\\(\d+)&#x2F;g, fescape) );
	}

	var makeArray = function( array, results ) {
		array = Array.prototype.slice.call( array, 0 );

		if ( results ) {
			results.push.apply( results, array );
			return results;
		}

		return array;
	};

	&#x2F;&#x2F; Perform a simple check to determine if the browser is capable of
	&#x2F;&#x2F; converting a NodeList to an array using builtin methods.
	&#x2F;&#x2F; Also verifies that the returned array holds DOM nodes
	&#x2F;&#x2F; (which is not the case in the Blackberry browser)
	try {
		Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

	&#x2F;&#x2F; Provide a fallback method if it does not work
	} catch( e ) {
		makeArray = function( array, results ) {
			var i = 0,
				ret = results || [];

			if ( toString.call(array) === &quot;[object Array]&quot; ) {
				Array.prototype.push.apply( ret, array );

			} else {
				if ( typeof array.length === &quot;number&quot; ) {
					for ( var l = array.length; i &lt; l; i++ ) {
						ret.push( array[i] );
					}

				} else {
					for ( ; array[i]; i++ ) {
						ret.push( array[i] );
					}
				}
			}

			return ret;
		};
	}

	var sortOrder, siblingCheck;

	if ( document.documentElement.compareDocumentPosition ) {
		sortOrder = function( a, b ) {
			if ( a === b ) {
				hasDuplicate = true;
				return 0;
			}

			if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
				return a.compareDocumentPosition ? -1 : 1;
			}

			return a.compareDocumentPosition(b) &amp; 4 ? -1 : 1;
		};

	} else {
		sortOrder = function( a, b ) {
			var al, bl,
				ap = [],
				bp = [],
				aup = a.parentNode,
				bup = b.parentNode,
				cur = aup;

			&#x2F;&#x2F; The nodes are identical, we can exit early
			if ( a === b ) {
				hasDuplicate = true;
				return 0;

			&#x2F;&#x2F; If the nodes are siblings (or identical) we can do a quick check
			} else if ( aup === bup ) {
				return siblingCheck( a, b );

			&#x2F;&#x2F; If no parents were found then the nodes are disconnected
			} else if ( !aup ) {
				return -1;

			} else if ( !bup ) {
				return 1;
			}

			&#x2F;&#x2F; Otherwise they&#x27;re somewhere else in the tree so we need
			&#x2F;&#x2F; to build up a full list of the parentNodes for comparison
			while ( cur ) {
				ap.unshift( cur );
				cur = cur.parentNode;
			}

			cur = bup;

			while ( cur ) {
				bp.unshift( cur );
				cur = cur.parentNode;
			}

			al = ap.length;
			bl = bp.length;

			&#x2F;&#x2F; Start walking down the tree looking for a discrepancy
			for ( var i = 0; i &lt; al &amp;&amp; i &lt; bl; i++ ) {
				if ( ap[i] !== bp[i] ) {
					return siblingCheck( ap[i], bp[i] );
				}
			}

			&#x2F;&#x2F; We ended someplace up the tree so do a sibling check
			return i === al ?
				siblingCheck( a, bp[i], -1 ) :
				siblingCheck( ap[i], b, 1 );
		};

		siblingCheck = function( a, b, ret ) {
			if ( a === b ) {
				return ret;
			}

			var cur = a.nextSibling;

			while ( cur ) {
				if ( cur === b ) {
					return -1;
				}

				cur = cur.nextSibling;
			}

			return 1;
		};
	}

	&#x2F;&#x2F; Utility function for retreiving the text value of an array of DOM nodes
	Sizzle.getText = function( elems ) {
		var ret = &quot;&quot;, elem;

		for ( var i = 0; elems[i]; i++ ) {
			elem = elems[i];

			&#x2F;&#x2F; Get the text from text nodes and CDATA nodes
			if ( elem.nodeType === 3 || elem.nodeType === 4 ) {
				ret += elem.nodeValue;

			&#x2F;&#x2F; Traverse everything else, except comment nodes
			} else if ( elem.nodeType !== 8 ) {
				ret += Sizzle.getText( elem.childNodes );
			}
		}

		return ret;
	};

	&#x2F;&#x2F; Check to see if the browser returns elements by name when
	&#x2F;&#x2F; querying by getElementById (and provide a workaround)
	(function(){
		&#x2F;&#x2F; We&#x27;re going to inject a fake input element with a specified name
		var form = document.createElement(&quot;div&quot;),
			id = &quot;script&quot; + (new Date()).getTime(),
			root = document.documentElement;

		form.innerHTML = &quot;&lt;a name=&#x27;&quot; + id + &quot;&#x27;&#x2F;&gt;&quot;;

		&#x2F;&#x2F; Inject it into the root element, check its status, and remove it quickly
		root.insertBefore( form, root.firstChild );

		&#x2F;&#x2F; The workaround has to do additional checks after a getElementById
		&#x2F;&#x2F; Which slows things down for other browsers (hence the branching)
		if ( document.getElementById( id ) ) {
			Expr.find.ID = function( match, context, isXML ) {
				if ( typeof context.getElementById !== &quot;undefined&quot; &amp;&amp; !isXML ) {
					var m = context.getElementById(match[1]);

					return m ?
						m.id === match[1] || typeof m.getAttributeNode !== &quot;undefined&quot; &amp;&amp; m.getAttributeNode(&quot;id&quot;).nodeValue === match[1] ?
							[m] :
							undefined :
						[];
				}
			};

			Expr.filter.ID = function( elem, match ) {
				var node = typeof elem.getAttributeNode !== &quot;undefined&quot; &amp;&amp; elem.getAttributeNode(&quot;id&quot;);

				return elem.nodeType === 1 &amp;&amp; node &amp;&amp; node.nodeValue === match;
			};
		}

		root.removeChild( form );

		&#x2F;&#x2F; release memory in IE
		root = form = null;
	})();

	(function(){
		&#x2F;&#x2F; Check to see if the browser returns only elements
		&#x2F;&#x2F; when doing getElementsByTagName(&quot;*&quot;)

		&#x2F;&#x2F; Create a fake element
		var div = document.createElement(&quot;div&quot;);
		div.appendChild( document.createComment(&quot;&quot;) );

		&#x2F;&#x2F; Make sure no comments are found
		if ( div.getElementsByTagName(&quot;*&quot;).length &gt; 0 ) {
			Expr.find.TAG = function( match, context ) {
				var results = context.getElementsByTagName( match[1] );

				&#x2F;&#x2F; Filter out possible comments
				if ( match[1] === &quot;*&quot; ) {
					var tmp = [];

					for ( var i = 0; results[i]; i++ ) {
						if ( results[i].nodeType === 1 ) {
							tmp.push( results[i] );
						}
					}

					results = tmp;
				}

				return results;
			};
		}

		&#x2F;&#x2F; Check to see if an attribute returns normalized href attributes
		div.innerHTML = &quot;&lt;a href=&#x27;#&#x27;&gt;&lt;&#x2F;a&gt;&quot;;

		if ( div.firstChild &amp;&amp; typeof div.firstChild.getAttribute !== &quot;undefined&quot; &amp;&amp;
				div.firstChild.getAttribute(&quot;href&quot;) !== &quot;#&quot; ) {

			Expr.attrHandle.href = function( elem ) {
				return elem.getAttribute( &quot;href&quot;, 2 );
			};
		}

		&#x2F;&#x2F; release memory in IE
		div = null;
	})();

	if ( document.querySelectorAll ) {
		(function(){
			var oldSizzle = Sizzle,
				div = document.createElement(&quot;div&quot;),
				id = &quot;__sizzle__&quot;;

			div.innerHTML = &quot;&lt;p class=&#x27;TEST&#x27;&gt;&lt;&#x2F;p&gt;&quot;;

			&#x2F;&#x2F; Safari can&#x27;t handle uppercase or unicode characters when
			&#x2F;&#x2F; in quirks mode.
			if ( div.querySelectorAll &amp;&amp; div.querySelectorAll(&quot;.TEST&quot;).length === 0 ) {
				return;
			}

			Sizzle = function( query, context, extra, seed ) {
				context = context || document;

				&#x2F;&#x2F; Only use querySelectorAll on non-XML documents
				&#x2F;&#x2F; (ID selectors don&#x27;t work in non-HTML documents)
				if ( !seed &amp;&amp; !Sizzle.isXML(context) ) {
					&#x2F;&#x2F; See if we find a selector to speed up
					var match = &#x2F;^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)&#x2F;.exec( query );

					if ( match &amp;&amp; (context.nodeType === 1 || context.nodeType === 9) ) {
						&#x2F;&#x2F; Speed-up: Sizzle(&quot;TAG&quot;)
						if ( match[1] ) {
							return makeArray( context.getElementsByTagName( query ), extra );

						&#x2F;&#x2F; Speed-up: Sizzle(&quot;.CLASS&quot;)
						} else if ( match[2] &amp;&amp; Expr.find.CLASS &amp;&amp; context.getElementsByClassName ) {
							return makeArray( context.getElementsByClassName( match[2] ), extra );
						}
					}

					if ( context.nodeType === 9 ) {
						&#x2F;&#x2F; Speed-up: Sizzle(&quot;body&quot;)
						&#x2F;&#x2F; The body element only exists once, optimize finding it
						if ( query === &quot;body&quot; &amp;&amp; context.body ) {
							return makeArray( [ context.body ], extra );

						&#x2F;&#x2F; Speed-up: Sizzle(&quot;#ID&quot;)
						} else if ( match &amp;&amp; match[3] ) {
							var elem = context.getElementById( match[3] );

							&#x2F;&#x2F; Check parentNode to catch when Blackberry 4.6 returns
							&#x2F;&#x2F; nodes that are no longer in the document #6963
							if ( elem &amp;&amp; elem.parentNode ) {
								&#x2F;&#x2F; Handle the case where IE and Opera return items
								&#x2F;&#x2F; by name instead of ID
								if ( elem.id === match[3] ) {
									return makeArray( [ elem ], extra );
								}

							} else {
								return makeArray( [], extra );
							}
						}

						try {
							return makeArray( context.querySelectorAll(query), extra );
						} catch(qsaError) {}

					&#x2F;&#x2F; qSA works strangely on Element-rooted queries
					&#x2F;&#x2F; We can work around this by specifying an extra ID on the root
					&#x2F;&#x2F; and working up from there (Thanks to Andrew Dupont for the technique)
					&#x2F;&#x2F; IE 8 doesn&#x27;t work on object elements
					} else if ( context.nodeType === 1 &amp;&amp; context.nodeName.toLowerCase() !== &quot;object&quot; ) {
						var old = context.getAttribute( &quot;id&quot; ),
							nid = old || id,
							hasParent = context.parentNode,
							relativeHierarchySelector = &#x2F;^\s*[+~]&#x2F;.test( query );

						if ( !old ) {
							context.setAttribute( &quot;id&quot;, nid );
						} else {
							nid = nid.replace( &#x2F;&#x27;&#x2F;g, &quot;\\$&amp;&quot; );
						}
						if ( relativeHierarchySelector &amp;&amp; hasParent ) {
							context = context.parentNode;
						}

						try {
							if ( !relativeHierarchySelector || hasParent ) {
								return makeArray( context.querySelectorAll( &quot;[id=&#x27;&quot; + nid + &quot;&#x27;] &quot; + query ), extra );
							}

						} catch(pseudoError) {
						} finally {
							if ( !old ) {
								context.removeAttribute( &quot;id&quot; );
							}
						}
					}
				}

				return oldSizzle(query, context, extra, seed);
			};

			for ( var prop in oldSizzle ) {
				Sizzle[ prop ] = oldSizzle[ prop ];
			}

			&#x2F;&#x2F; release memory in IE
			div = null;
		})();
	}

	(function(){
		var html = document.documentElement,
			matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector,
			pseudoWorks = false;

		try {
			&#x2F;&#x2F; This should fail with an exception
			&#x2F;&#x2F; Gecko does not error, returns false instead
			matches.call( document.documentElement, &quot;[test!=&#x27;&#x27;]:sizzle&quot; );

		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		if ( matches ) {
			Sizzle.matchesSelector = function( node, expr ) {
				&#x2F;&#x2F; Make sure that attribute selectors are quoted
				expr = expr.replace(&#x2F;\=\s*([^&#x27;&quot;\]]*)\s*\]&#x2F;g, &quot;=&#x27;$1&#x27;]&quot;);

				if ( !Sizzle.isXML( node ) ) {
					try {
						if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) &amp;&amp; !&#x2F;!=&#x2F;.test( expr ) ) {
							return matches.call( node, expr );
						}
					} catch(e) {}
				}

				return Sizzle(expr, null, null, [node]).length &gt; 0;
			};
		}
	})();

	(function(){
		var div = document.createElement(&quot;div&quot;);

		div.innerHTML = &quot;&lt;div class=&#x27;test e&#x27;&gt;&lt;&#x2F;div&gt;&lt;div class=&#x27;test&#x27;&gt;&lt;&#x2F;div&gt;&quot;;

		&#x2F;&#x2F; Opera can&#x27;t find a second classname (in 9.6)
		&#x2F;&#x2F; Also, make sure that getElementsByClassName actually exists
		if ( !div.getElementsByClassName || div.getElementsByClassName(&quot;e&quot;).length === 0 ) {
			return;
		}

		&#x2F;&#x2F; Safari caches class attributes, doesn&#x27;t catch changes (in 3.2)
		div.lastChild.className = &quot;e&quot;;

		if ( div.getElementsByClassName(&quot;e&quot;).length === 1 ) {
			return;
		}

		Expr.order.splice(1, 0, &quot;CLASS&quot;);
		Expr.find.CLASS = function( match, context, isXML ) {
			if ( typeof context.getElementsByClassName !== &quot;undefined&quot; &amp;&amp; !isXML ) {
				return context.getElementsByClassName(match[1]);
			}
		};

		&#x2F;&#x2F; release memory in IE
		div = null;
	})();

	function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
		for ( var i = 0, l = checkSet.length; i &lt; l; i++ ) {
			var elem = checkSet[i];

			if ( elem ) {
				var match = false;

				elem = elem[dir];

				while ( elem ) {
					if ( elem.sizcache === doneName ) {
						match = checkSet[elem.sizset];
						break;
					}

					if ( elem.nodeType === 1 &amp;&amp; !isXML ){
						elem.sizcache = doneName;
						elem.sizset = i;
					}

					if ( elem.nodeName.toLowerCase() === cur ) {
						match = elem;
						break;
					}

					elem = elem[dir];
				}

				checkSet[i] = match;
			}
		}
	}

	function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
		for ( var i = 0, l = checkSet.length; i &lt; l; i++ ) {
			var elem = checkSet[i];

			if ( elem ) {
				var match = false;

				elem = elem[dir];

				while ( elem ) {
					if ( elem.sizcache === doneName ) {
						match = checkSet[elem.sizset];
						break;
					}

					if ( elem.nodeType === 1 ) {
						if ( !isXML ) {
							elem.sizcache = doneName;
							elem.sizset = i;
						}

						if ( typeof cur !== &quot;string&quot; ) {
							if ( elem === cur ) {
								match = true;
								break;
							}

						} else if ( Sizzle.filter( cur, [elem] ).length &gt; 0 ) {
							match = elem;
							break;
						}
					}

					elem = elem[dir];
				}

				checkSet[i] = match;
			}
		}
	}

	if ( document.documentElement.contains ) {
		Sizzle.contains = function( a, b ) {
			return a !== b &amp;&amp; (a.contains ? a.contains(b) : true);
		};

	} else if ( document.documentElement.compareDocumentPosition ) {
		Sizzle.contains = function( a, b ) {
			return !!(a.compareDocumentPosition(b) &amp; 16);
		};

	} else {
		Sizzle.contains = function() {
			return false;
		};
	}

	Sizzle.isXML = function( elem ) {
		&#x2F;&#x2F; documentElement is verified for cases where it doesn&#x27;t yet exist
		&#x2F;&#x2F; (such as loading iframes in IE - #4833)
		var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

		return documentElement ? documentElement.nodeName !== &quot;HTML&quot; : false;
	};

	var posProcess = function( selector, context ) {
		var match,
			tmpSet = [],
			later = &quot;&quot;,
			root = context.nodeType ? [context] : context;

		&#x2F;&#x2F; Position selectors must be done after the filter
		&#x2F;&#x2F; And so must :not(positional) so we move all PSEUDOs to the end
		while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
			later += match[0];
			selector = selector.replace( Expr.match.PSEUDO, &quot;&quot; );
		}

		selector = Expr.relative[selector] ? selector + &quot;*&quot; : selector;

		for ( var i = 0, l = root.length; i &lt; l; i++ ) {
			Sizzle( selector, root[i], tmpSet );
		}

		return Sizzle.filter( later, tmpSet );
	};

	&#x2F;********************************************** 返回类 **********************************************&#x2F;
	
	return Sizzle;
	
});
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
