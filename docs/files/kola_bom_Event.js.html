<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>kola\bom\Event.js - kola</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.5.1&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.5.1&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="..&#x2F;assets/css/logo.png" title="kola"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 2.0.0</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Array.html">Array</a></li>
            
                <li><a href="..&#x2F;classes/Class.html">Class</a></li>
            
                <li><a href="..&#x2F;classes/Function.html">Function</a></li>
            
                <li><a href="..&#x2F;classes/Package.html">Package</a></li>
            
                <li><a href="..&#x2F;classes/String.html">String</a></li>
            
                <li><a href="..&#x2F;classes/window.html">window</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/kola.html">kola</a></li>
            
                <li><a href="..&#x2F;modules/kola.lang.html">kola.lang</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: kola\bom\Event.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * @fileOverview kola.bom.Event 事件支持类
 * @author Jady Yang
 * @version 2.0.0
 * @fix scope bug 2011-03-30 by flyhuang
 *&#x2F;


kola(&#x27;kola.bom.Event&#x27;, [
    &#x27;kola.lang.Object&#x27;,
    &#x27;kola.lang.Function&#x27;,
    &#x27;kola.lang.Array&#x27;,
    &#x27;kola.bom.Browser&#x27;,
    &#x27;kola.lang.Class&#x27;,
    &#x27;kola.css.Selector&#x27;
],function(KolaObject, KolaFunction, KolaArray , B, C, Selector) {
	
	&#x2F;********************************************** 类定义 **********************************************&#x2F;

    &#x2F;&#x2F;FIXME:给window绑定onscroll事件没有位置信息
    var copyParams=[&quot;keyCode&quot;,&quot;ctrlKey&quot;,&quot;shiftKey&quot;,&quot;clientX&quot;,&quot;clientY&quot;,&quot;screenX&quot;,&quot;screenY&quot;];
    &#x2F;**
	 * kola事件对象
	 * @prop currentTarget 绑定时没有设置option.delegate时，currentTarget为绑定该事件的元素，设置option.delegate时，currentTarget为被代理的元素
     * @prop data: 绑定事件时传入的数据
     * @prop event: 浏览器内置事件对象
     * @prop button: w3c兼容
     * @method preventDefault: w3c兼容
     * @method stopPropagation: w3c兼容
     * @method stop: preventDefault &amp; stopPropagation
	 *&#x2F;
    function DomEvent(e){
        this.event=e;
        if(B.IEStyle){
            this.target=e.srcElement;
            this.relatedTarget = ( e.fromElement == e.srcElement ? e.toElement : e.fromElement );
            if(e.button==1)
                this.button=0;
            if(e.button==4)
                this.button=1;
            if(e.button==2)
                this.button=2;
        }else{
            this.target=e.target;
            this.button=e.button;
            this.relatedTarget = e.relatedTarget;
        }
        for(var i=0,il=copyParams.length;i&lt;il;i++){
            this[copyParams[i]]=e[copyParams[i]];
        }
     }
     if(B.IEStyle){
         C.buildProto(DomEvent,{
             preventDefault:function(){this.event.returnValue=false;},
             stopPropagation:function(){this.event.cancelBubble=true;}
         });
     }else{
         C.buildProto(DomEvent,{
            preventDefault:function(){
                this.event.preventDefault()
            },
            stopPropagation:function(){
                this.event.stopPropagation()
            }
         });
     }
     DomEvent.prototype.stop=function(){
        this.preventDefault();
        this.stopPropagation();
     }
	
	var eventAgent = function( listenerfn, option, e ) {
		if ( B.IEStyle ) {
            e= new DomEvent(window.event);
		}else{
            e= new DomEvent(e);
        }
        if(option.out){
            var elem=e.target;
            var match=false;
            while(elem.nodeType==1 &amp;&amp; elem!=this){
                elem = elem.parentNode;
            }
            e.currentTarget = this;
            if(elem!=this)
                listenerfn.call( option.scope||this, e );
            return;
        }
        &#x2F;&#x2F;当前事件是代理
        if(option.delegate){
            var elem=e.target;
            var match=false;
            while(elem.nodeType==1 &amp;&amp; elem!=this){
                if(Selector.matchesSelector(elem,option.delegate)){
                    match=elem;
                    break;
                }
                elem = elem.parentNode;
            }
            &#x2F;&#x2F;若target不是delegate的一部分，则放弃事件
            if(!match)
                return;
            e.currentTarget = elem;
        }else{
            e.currentTarget = this;
        }
        if(!KolaObject.isUndefined(option.data))
            e.data=option.data;
        
		listenerfn.call( option.scope||this, e );
	};
    &#x2F;&#x2F;light bind
    function eventBind(callbackfn,scope,listenerfn,option) {
        return function(e) {
            return callbackfn.call(scope,listenerfn,option,e);
        };
    }
	&#x2F;&#x2F;删除指定的事件
	var remove = function( element, name, listenerfn, obj ) {
		&#x2F;&#x2F;	删除listener
		if ( element.removeEventListener ) {
            if(obj.o.out)
                document.removeEventListener( name, listenerfn, false );
            else
                element.removeEventListener( name, listenerfn, false );
		} else {
			&#x2F;&#x2F;	如果是监听checkbox input的onchange事件，那就需要监听替代的事件。这样做主要是解决，ie9之前，点击checkbox input时，并不会马上出发onchange事件，而是在失焦后出发onchange事件的问题
			if ( name == &#x27;change&#x27; &amp;&amp; element.tagName &amp;&amp; element.tagName.toLowerCase() == &#x27;input&#x27; &amp;&amp; element.type == &#x27;checkbox&#x27; ) {
				CheckboxChange.off( element, obj );
			} else {
                if(obj.o.out)
                    document.detachEvent( &quot;on&quot;+name, listenerfn );
                else
                    element.detachEvent( &quot;on&quot;+name, listenerfn );
			}
		}
	};

	&#x2F;&#x2F;常见的inline事件
	var inlineEvents = [
		&#x27;onclick&#x27;, &#x27;ondblclick&#x27;, &#x27;onmouseover&#x27;, &#x27;onmouseout&#x27;, &#x27;onmouseup&#x27;, &#x27;onmousedown&#x27;,
		&#x27;onblur&#x27;, &#x27;onfocus&#x27;, &#x27;onchange&#x27;, &#x27;onsubmit&#x27;
	];

	var KEvent = {
		&#x2F;**
		 * 监听一个事件
         * @param {kolaElement} element 要绑定事件的元素
         * @param {String} name 事件名称
         * @param {function} listenerfn 事件的处理函数
         * @param {object} option 配置参数
                @option {object} scope 指定处理函数的this，如果没有，则默认为element
                @option {ANY} data 绑定事件时附带的参数，事件处理时会附加在event.data中
                @option {selector} delegate 代理事件，如果设置，只有符合该选择器的子元素才会触发事件，并且currentTarget指向被代理的元素
                @option {Boolean} out 指定事件在当前元素之外触发
		 *&#x2F;
		on: function(element, name, listenerfn, option) {
			if ( !element || !name || !listenerfn ) return this;
			option=option||{};
			&#x2F;&#x2F;	如果是IE7下触发unload事件，那就直接设置方法
			if ( name == &#x27;unload&#x27; &amp;&amp; element == window &amp;&amp; B.IE67 ) {
				element.onunload = listenerfn;
				return this;
			}

			&#x2F;&#x2F;	如果不存在事件存储器的话，那就建立之
			var events = element.__events;
			if( !events ) {
				events = element.__events = {};
			}

			&#x2F;&#x2F;	如果不存在指定类型的事件存储器，那就建立之
			var eventType = events[ name ];
			if( !eventType ) {
				eventType = events[ name ] = [];
			}

			var obj;

            &#x2F;&#x2F;	建立替代方法，主要是设定作用域
            obj = {
                l: listenerfn,
                h: eventBind(eventAgent, element, listenerfn, option),
                o: option
            };

			&#x2F;&#x2F;	缓存事件处理方法
			eventType.push( obj );
					
			&#x2F;&#x2F;	绑定事件
			if ( !B.IEStyle ) {
                if(option.out){
                    document.addEventListener( name, obj.h, false );
                }else{
                    element.addEventListener( name, obj.h, false );
                }
			} else {
				&#x2F;&#x2F;	如果是监听checkbox input的onchange事件，那就需要监听替代的事件。这样做主要是解决，ie9之前，点击checkbox input时，并不会马上出发onchange事件，而是在失焦后出发onchange事件的问题
				if ( name == &#x27;change&#x27; &amp;&amp; element.tagName &amp;&amp; element.tagName.toLowerCase() == &#x27;input&#x27; &amp;&amp; element.type == &#x27;checkbox&#x27; ) {
					CheckboxChange.on( element, obj.h, obj );
				} else {
                    if(option.out)
                        document.attachEvent( &#x27;on&#x27; + name, obj.h );
                    else
                        element.attachEvent( &#x27;on&#x27; + name, obj.h );
				}
			}
					
			return this;
		},
		
		&#x2F;**
		 * 取消元素的所有事件绑定
         * @param {kolaElement} element 要解除事件绑定的元素
		 *&#x2F;
        
        &#x2F;**
		 * 取消元素的某个类型事件绑定
         * @param {kolaElement} element 要解除事件绑定的元素
         * @param {String} name 要解除事件绑定的类型
		 *&#x2F;
        
        &#x2F;**
		 * 取消元素的指定事件处理
         * @param {kolaElement} element 要解除事件绑定的元素
         * @param {String} name 要解除事件绑定的类型
         * @param {Function} listenerfn 要解除事件绑定的处理函数
		 *&#x2F;
		off: function( element, name, listenerfn, out) {
			if ( !element ) return this;

			&#x2F;&#x2F;	如果不存在事件缓存，那就不做处理
			var events = element.__events;
			if( !events ) return this;
			
			&#x2F;&#x2F;	如果不存在要移除的事件，那就是移除所有事件
			var listeners;
			if ( typeof name == &#x27;undefined&#x27; ) {
				&#x2F;&#x2F;	移除所有事件
				for ( var key in events ) {
					if ( key == &#x27;out&#x27; ) {
						&#x2F;&#x2F;	如果是out事件，那就删除所有out事件
						KEvent.unout( element );
					} else {
                        if(out){
                            this.off(document, name, listenerfn);
                            return this;
                        }
						listeners = events[ key ];
						if ( typeof listeners != &#x27;object&#x27; || ( listeners == null ) || !listeners.length ) continue;
						
						&#x2F;&#x2F;	循环取消所有事件监听
						for ( var i = listeners.length - 1; i &gt;= 0; i-- ) {
							var listener = listeners[i];
							remove( element, key, listener.h, listener );
						}
					}
				}
				
				&#x2F;&#x2F;	删除常见的inline事件
				for ( var j = inlineEvents.length - 1; j &gt;= 0; j-- ) {
					element[ inlineEvents[ i ] ] = null;
				}
				
				&#x2F;&#x2F;	清除事件缓存
				element.__events = null;
				element.__events = undefined;
			} else {
				&#x2F;&#x2F;	移除指定事件的监听
				
				&#x2F;&#x2F;	如果不存在该类型的事件存储器，那就不做处理
				listeners = events[name];
				if( !listeners ) return this;

				if( listenerfn ) {
					&#x2F;&#x2F;	这是要取消指定的监听方法
	
					&#x2F;&#x2F;	循环所有存储的事件处理方法，如果相同，那就删除之
					for( var i = listeners.length - 1; i &gt;= 0; i-- ) {
						var eventObj = listeners[i];
						if ( eventObj.l == listenerfn ) {
							remove( element, name, eventObj.h, eventObj );
							listeners.splice( i, 1 );
							break;
						}
					}
		
				} else {
					&#x2F;&#x2F;	删除所有监听事件
					for( var i = 0, il = listeners.length; i &lt; il; i++ ) {
						remove( element, name, listeners[i].h, listeners[i] );
					}
	
					&#x2F;&#x2F;	删除缓存
					delete events[name];
				}		
				return this;
			}
		},
		&#x2F;**
		 * 派发事件
		 * @param element
		 * @param name
		 * @param event
		 *&#x2F;
		fire: function( element, name, event ) {
            if(B.IEStyle) {  
                element.fireEvent(&quot;on&quot;+name);  
            }else{  
                var evt = document.createEvent(&#x27;HTMLEvents&#x27;);  
                evt.initEvent(name,true,true);  
                element.dispatchEvent(evt);  
            }
            &#x2F;*
			&#x2F;&#x2F;	TODO: 暂时没有内浏览器内置事件增加良好支持

			&#x2F;&#x2F;	如果没有监听器，那就不做处理
			var listeners;
			if ( !( listeners = element.__events ) || !( listeners = listeners[ name ] ) ) return;

			&#x2F;&#x2F;	如果不存在事件对象，那就建立之
			event = event || {};
			event.type = name;

			&#x2F;&#x2F;	循环每个监听器，依次执行之
			for ( var i = 0, il = listeners.length; i &lt; il; i++ ) {
				listeners[ i ].h.call( element, event );
			}*&#x2F;
		}
    };

	&#x2F;* ---------------------------------- checkbox input change事件的特殊处理程序 ----------------------------------------*&#x2F;

	var CheckboxChange = {

		&#x2F;**
		 * 监听方法
		 *&#x2F;
		on: function( element, listenerfn, obj ) {
			&#x2F;&#x2F;	设定两个方法
			var clickfn = KolaFunction.bind( CheckboxChange.fire, this, element, listenerfn );
			var keypressfn = KolaFunction.bind( CheckboxChange.keypress, this, element, listenerfn );

			&#x2F;&#x2F;  记录监听方法
			obj.click = clickfn;
			obj.keypress = keypressfn;

			&#x2F;&#x2F;  监听替代变量
			Event.on( element, &#x27;click&#x27;, clickfn );
			Event.on( element, &#x27;keypress&#x27;, keypressfn );
		},

		&#x2F;**
		 * 取消对元素的替代事件的监听
		 *&#x2F;
		off: function( element, obj ) {
			Event.off( element, &#x27;click&#x27;, obj.click );
			Event.off( element, &#x27;keypress&#x27;, obj.keypressfn );
		},

		&#x2F;**
		 * keypress事件的处理方法
		 *&#x2F;
		keypress: function( element, listenerfn, e ) {
			&#x2F;&#x2F;	如果当前按的是空格，那就触发onchange事件
			if ( e.keyCode == 32 ) {
				CheckboxChange.fire( element, listenerfn );
			}
		},

		&#x2F;**
		 * 触发change事件
		 *&#x2F;
		fire: function( element, listenerfn ) {
			&#x2F;&#x2F;	循环每个监听change的处理器，调用之执行
			KolaArray.forEach( element.__events[ &#x27;change&#x27; ], function( obj ) {
				var e = {
					srcElement: element,
					type: &#x27;change&#x27;
				};
				obj.h( e );
			} );
		}
	};

	return KEvent;
	
});
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
